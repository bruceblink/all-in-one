# 分布式应用运行时操作系统（Distributed Application Runtime OS）设计文档

本文档用于描述一个面向**应用（Application）**的、分布式的运行时操作系统 —— **D-AROS（Distributed Application Runtime Operating System）** 的设计目标、责任边界、核心抽象与总体架构，用于指导工程实现、系统评审与长期演进。

---

## 1. 背景与问题定义

### 1.1 背景

随着应用形态从单体程序演进为**跨节点、跨资源池的分布式系统**，传统单机操作系统在进程管理、调度与资源隔离层面提供的能力，已无法覆盖“**应用整体运行态**”的管理需求。

在云原生体系中，Kubernetes 在工程实践上成功解决了以下关键问题：

- 容器化执行环境的标准化
- 基础资源抽象（CPU / Memory / Device）
- Pod 级别的调度、自愈与扩缩容

然而，Kubernetes 的设计目标是一个**通用的集群操作系统（Cluster OS）**，而非面向“应用语义”的运行时系统。

---

### 1.2 现有方案的结构性不足

在大规模分布式系统实践中，现有方案逐渐暴露出以下结构性不足：

- **缺乏应用级抽象** 
  Kubernetes 以 Pod / Workload 为中心，无法原生表达“一个应用由多个组件组成，并具有整体运行目标”的概念。

- **调度缺乏业务裁决能力** 
  调度决策以资源可行性为核心，难以统一处理 SLA、优先级、成本等业务级约束。

- **PaaS 平台能力退化** 
  多数 PaaS 平台仅对 Kubernetes API 进行 CRUD 封装，而未真正承担运行时控制平面的职责。

---

### 1.3 问题定义

是否可以在现有分布式内核之上，引入一个**以应用为一等公民**的运行时操作系统抽象，用于统一描述、裁决与控制分布式应用的运行状态？

**D-AROS** 即为对此问题的系统化回答。

---

## 2. 系统定位与责任边界（核心约束）

### 2.1 系统定位

D-AROS 的系统定位是：

> **位于集群操作系统之上的分布式应用运行时操作系统（Application Runtime OS）**

它不直接管理物理资源，也不承载业务逻辑，而是负责：

- 描述应用“**应该如何运行**”
- 在多应用之间进行**运行时裁决（Arbitration）**
- 将裁决结果下发给底层集群内核执行

---

### 2.2 分层视图

```text
┌────────────────────────────────┐
│  Application / Platform Layer  │  ← 业务系统 / CI/CD / 控制台
├────────────────────────────────┤
│        D-AROS Runtime OS       │  ← 应用模型 / 生命周期 / 裁决
├────────────────────────────────┤
│   Cluster OS (K8s / Nomad)     │  ← Pod / Task 调度与执行
├────────────────────────────────┤
│      Infrastructure Layer      │  ← 物理机 / 网络 / 存储
└────────────────────────────────┘
```

---

### 2.3 责任边界定义

**D-AROS 的职责（必须承担）：**

- 应用运行时抽象建模
- 应用生命周期状态机管理
- 应用级资源裁决与优先级控制
- 调度策略与机制解耦

**D-AROS 明确不承担的职责：**

- 不管理物理节点生命周期
- 不实现容器 / Pod 级调度
- 不替代 Kubernetes / Nomad 的核心能力

> 任何越过该边界的设计，都会导致系统复杂度失控。

---

## 3. 设计目标与原则

### 3.1 核心目标

为分布式应用提供类似单机操作系统的能力：

- 可描述的运行态（Describable State）
- 可裁决的资源使用（Arbitrable Resource Usage）
- 可预测的生命周期演进（Predictable Lifecycle）

---

### 3.2 设计原则

- **Application-first**：应用是一等公民
- **声明式驱动**：描述期望状态，而非命令式操作
- **策略与机制解耦**：机制稳定，策略可演进
- **不重复造轮子**：复用成熟的 Cluster OS

------

## 4. 核心抽象与对象模型（多运行时版本）

本章定义 D-AROS 的核心对象模型。这些抽象共同构成一个**以应用为中心、与具体运行时解耦**的分布式应用运行时操作系统内核。

------

### 4.1 Application（应用，一等公民）

> **Application 是 D-AROS 中的最高级抽象单位。**

Application 表示一个具有**整体运行目标、生命周期和资源边界**的分布式应用实例。

Application 责任描述：

- Application 由哪些 **Workload** 组成
- Application 整体的 **运行目标（SLA / QoS）**
- Application 的 **资源预算与优先级**
- Application 的 **生命周期策略**

Application **不关心**：

- 具体运行在哪种操作系统
- 使用哪种运行时技术（容器 / 虚拟机 / 进程）

> 👉 Application 是“运行时无关的逻辑实体”。

------

### 4.2 Workload（运行负载，运行时无关抽象）

> **Workload 是 D-AROS 中“可被调度和执行的最小单位”。**

与 Kubernetes Pod 不同，Workload 是一个**运行时中立（Runtime-Agnostic）**的抽象。

------

#### 4.2.1 Workload 的核心职责

Workload 用于描述：

- **需要被执行的计算单元**
- **所需的运行时环境能力**
- **资源需求**
- **生命周期控制边界**

但不直接绑定任何具体执行技术。

------

#### 4.2.2 Workload 抽象结构

```text
Workload
├── RuntimeRequirement
│   ├── RuntimeType
│   └── OSRequirement
├── ResourceProfile
├── LifecyclePolicy
└── RuntimeSpec (Opaque)
```

------

#### 4.2.3 RuntimeRequirement

RuntimeRequirement 用于显式描述 Workload 对运行环境的要求：

- **RuntimeType**
  - container
  - virtual-machine
  - process
- **OSRequirement**
  - linux
  - windows

示例（概念性）：

```yaml
runtime:
  type: container
  os: linux
```

> 👉 这是 D-AROS 支持多运行时的**最小、也是最关键的建模点**。

------

#### 4.2.4 RuntimeSpec

RuntimeSpec 是对具体运行时的**不透明描述**：

- 对 D-AROS Control Plane **不可解析**
- 仅由对应的 Runtime Adapter 理解

示例：

- Container RuntimeSpec：PodTemplate
- VM RuntimeSpec：VM Image / Disk / Cloud-Init
- Windows RuntimeSpec：Service Definition / Binary Path

> 👉 Control Plane 永远不直接依赖 RuntimeSpec 结构。

------

### 4.3 Execution Node（执行节点）

> **Execution Node 表示“可以承载 Workload 的执行实体”。**

Execution Node 是对底层计算节点的统一抽象，可能对应：

- Kubernetes Node（Linux / Windows）
- 虚拟化宿主机
- 裸金属节点

------

#### 4.3.1 Execution Node 能力模型

```text
ExecutionNode
├── ResourceCapacity
├── OS
├── SupportedRuntimes
└── RuntimeCapabilities
```

示例：

- Linux Node
  - container ✅
  - vm ✅
  - windows-container ❌
- Windows Node
  - windows-container ✅
  - vm ❓

------

### 4.4 Resource Pool（资源池）

> **Resource Pool 是对底层资源的逻辑聚合视图。**

Resource Pool 提供的是：

- **可裁决容量**
- 而非具体节点资源

它屏蔽了节点异构性，为调度与裁决提供统一输入。

------

### 4.5 Runtime（运行时，新增一等抽象）

> **Runtime 是 Workload 实际执行的技术载体。**

Runtime 本身也是 D-AROS 的一等概念，但只存在于**控制平面与数据平面之间的边界**。

------

#### 4.5.1 Runtime 的系统定位

Runtime 位于：

```text
D-AROS Control Plane
        ↓
    Runtime Adapter
        ↓
   Cluster OS / Hypervisor
```

D-AROS **不直接操作**：

- Pod
- VM
- Windows Service

而是通过 Runtime Adapter 间接控制。

------

#### 4.5.2 Runtime Adapter（新增，关键组件）

Runtime Adapter 负责将 D-AROS 的通用控制指令，翻译为具体运行时的操作。

统一接口示意：

```text
RuntimeAdapter
├── Create
├── Start
├── Stop
├── Destroy
└── Inspect
```

典型实现：

- Kubernetes Runtime Adapter
- KubeVirt / VM Adapter
- Windows Runtime Adapter

> 👉 Runtime Adapter 是平台可扩展性的唯一入口。

------

### 4.6 Application Instance（运行实例）

> **Application Instance 表示 Application 在某一时刻的具体运行态。**

它关联：

- Application Spec
- 一组 Workload Instance
- 当前 Lifecycle Phase
- Runtime 状态汇总

------

### 4.7 Failure Model（失败模型，升级）

> **失败被建模为跨层、跨运行时的系统事件，而非单一 Pod 异常。**

#### 4.7.1 失败类型分类

```text
Failure
├── Infrastructure Failure
├── Runtime Failure
│   ├── ContainerCrash
│   ├── VMExit
│   ├── WindowsServiceStopped
├── Application Failure
└── Control Plane Failure
```

#### 4.7.2 失败的处理原则

- D-AROS 感知 **失败语义**
- Runtime Adapter 处理 **失败细节**
- Application Lifecycle 决定 **应对策略**

------

### 4.8 抽象设计总结

通过以上模型，D-AROS 明确实现了：

- **应用与运行时解耦**
- **调度与执行解耦**
- **策略与机制解耦**

从而支持：

- Linux / Windows 混合集群
- Container / VM / 未来运行时
- 应用级调度与裁决

---

## 5. 调度与资源裁决模型

### 5.1 调度问题抽象

调度在 D-AROS 中被抽象为：

> 在多应用、多约束条件下的**资源裁决问题（Arbitration）**

主要约束包括：

- 资源容量限制
- 应用优先级
- SLA / 延迟目标
- 系统整体利用率

---

### 5.2 多级调度模型

1. **准入裁决（Admission Control）**
2. **放置决策提示（Placement Hint）**
3. **抢占与降级（Preemption / Degradation）**

> D-AROS 仅输出裁决结果，不负责具体节点选择。

---

### 5.3 调度策略插件化

- Bin-Pack（资源利用率优先）
- Spread（可用性优先）
- SLA-Aware（低延迟优先）
- Cost-Aware（成本约束）

------

## 6. 应用生命周期管理

本章描述 D-AROS 如何以**应用为一等公民**，对分布式应用的运行状态进行建模、控制与演进，并明确生命周期系统在整体架构中的地位与约束。

------

### 6.1 生命周期系统的设计目标

D-AROS 的生命周期管理并非简单的“状态标记”，而是承担以下核心职责：

- 提供 **全局一致的应用运行状态视图**
- 作为 **运行时控制与裁决的唯一入口**
- 约束系统行为，防止控制逻辑失序
- 支撑应用级调度、扩缩容、降级、终止等操作

> 生命周期系统在 D-AROS 中的角色，等价于：
>
> **单机操作系统中的「进程状态机 + 系统调用边界」**

------

### 6.2 生命周期对象与状态域划分

#### 6.2.1 生命周期对象

生命周期管理的**最小控制对象**是：

> **Application Instance（应用实例）**

而非：

- 单个 Pod
- 单个 Component
- 单个任务或容器

所有生命周期状态，均以 **Application Instance** 为粒度。

------

#### 6.2.2 状态域划分原则

生命周期状态被划分为两类：

- **期望态（Desired State）**
- **现实态（Observed State）**

```text
Application Spec        ← 期望态（用户声明）
Application Status      ← 现实态（系统裁决与执行结果）
```

D-AROS 的生命周期系统负责：

- 比较期望态与现实态
- 通过状态迁移，推动系统向期望态收敛

------

### 6.3 生命周期状态定义

#### 6.3.1 核心生命周期状态

D-AROS 定义如下应用生命周期状态：

| 状态       | 含义                               |
| ---------- | ---------------------------------- |
| Created    | 应用对象已创建，但尚未参与任何裁决 |
| Admitted   | 通过准入裁决，获得运行资格         |
| Scheduled  | 完成应用级调度决策，等待底层执行   |
| Running    | 应用组件已启动并处于正常运行       |
| Degraded   | 资源不足或策略触发下的降级运行     |
| Terminated | 应用已被显式或隐式终止             |

------

#### 6.3.2 状态的语义约束

- **状态是“裁决结果”，不是操作命令**
- 状态只能由生命周期系统修改
- 外部系统不得绕过状态机直接操纵运行实体

> 👉 **状态不是标签，而是系统的“法律状态”**

------

### 6.4 生命周期状态机模型

#### 6.4.1 状态迁移总览

```text
Created
   ↓
Admitted ──────→ Rejected
   ↓
Scheduled
   ↓
Running ──────→ Degraded
   ↓               ↑
Terminated ◀───────┘
```

------

#### 6.4.2 关键状态迁移说明

#### Created → Admitted

- 触发条件：
  - 应用描述合法
  - 租户配额未超限
  - 全局策略允许准入
- 触发模块：
  - Admission Controller
  - Resource & Quota Manager

------

#### Admitted → Scheduled

- 触发条件：
  - 调度与裁决引擎完成应用级资源裁决
- 迁移结果：
  - 生成组件级运行计划
  - 输出 Placement Hint / Resource Allocation

------

#### Scheduled → Running

- 触发条件：
  - 底层 Cluster OS 成功创建并启动实例
- 说明：
  - D-AROS 不保证所有组件同时 Ready
  - 以“应用整体可运行”为判断标准

------

#### Running → Degraded

- 触发条件：
  - 资源压力超过阈值
  - 高优先级应用抢占
  - 策略明确允许降级
- 行为：
  - 减少副本
  - 降低 QoS
  - 关闭非关键组件

------

#### 任意状态 → Terminated

- 触发条件：
  - 用户主动终止
  - 策略驱逐
  - 不可恢复的系统异常

------

### 6.5 生命周期驱动模型（State-Driven Control）

#### 6.5.1 生命周期即控制入口

D-AROS 明确采用：

> **State-Driven Control Model**

即：

- 所有控制动作，必须由状态迁移触发
- 不允许直接操作底层执行实体

```text
State Transition
      ↓
Reconciliation Loop
      ↓
Cluster Adapter Actions
```

------

#### 6.5.2 Reconciliation Loop 的职责

- 监听状态变化
- 计算当前状态与目标状态差异
- 生成最小化执行动作集合
- 将动作下发给 Cluster OS Adapter

------

### 6.6 生命周期与调度系统的协作关系

生命周期系统与调度系统之间的关系为：

```text
Lifecycle System  ←→  Arbitration Engine
```

- 生命周期系统：
  - 定义“应用处于什么阶段”
- 裁决引擎：
  - 决定“该阶段是否可以推进”

> 👉 **生命周期系统负责秩序，调度系统负责裁决**

------

### 6.7 生命周期系统的边界约束（重要）

#### 6.7.1 明确禁止的行为

- 生命周期系统不得：
  - 直接调用 Kubernetes Scheduler
  - 感知具体 Node / Pod 细节
  - 维护执行层瞬时状态

------

#### 6.7.2 允许的最小感知

生命周期系统仅感知：

- 应用级健康状态
- 组件级 Ready / Failed 汇总信息
- 资源使用的聚合视图

------

### 6.8 生命周期系统的系统意义

通过引入应用级生命周期系统，D-AROS 实现了：

- 应用运行状态的**全局一致性**
- 调度、扩缩容、降级行为的**可预测性**
- 控制逻辑的**去命令化、去耦合**

> **生命周期系统是 D-AROS 的“时间轴”与“秩序基础”**

------

### 6.9 本章小结

本章明确了：

- 生命周期是 D-AROS 的核心控制机制
- 应用状态是系统唯一可信的控制入口
- 所有运行时行为必须通过状态迁移驱动

这为后续的 **调度裁决、资源管理与系统演进** 提供了稳定的系统基础。

---

## 7. 控制平面与数据平面

### 7.1 控制平面（Control Plane）

- Application API Server
- 调度与裁决引擎
- 状态管理器

---

### 7.2 数据平面（Data Plane）

- 实际运行的应用实例
- 由 Cluster OS 负责执行

---

## 8. 为什么 Kubernetes Scheduler 不适合作为应用调度器

这一节用于**明确 Kubernetes 的调度器边界**，解释为什么它不能直接承担“分布式应用运行时操作系统”中 **应用级调度器（Application Scheduler）** 的职责，从而为“为什么需要在 K8s 之上构建一层应用运行时系统”提供技术上的正当性。

### **8.1 Kubernetes Scheduler 的设计目标**

Kubernetes Scheduler 的核心职责是：

> **为 Pod 选择一个合适的 Node**

其调度决策围绕以下问题展开：

- 这个 Pod 能不能放到某个 Node 上？（Predicate / Filter）
- 放到哪个 Node 上“更合适”？（Priority / Score）

它关注的核心维度包括：

- CPU / Memory / Ephemeral Storage 等**节点级资源**
- Node Label / Taint / Toleration
- Pod Affinity / Anti-Affinity
- Topology Spread Constraints

👉 **本质上，Kubernetes Scheduler 是一个「节点资源调度器」**，而不是应用调度器。



### **8.2 应用调度器需要解决的问题（K8s Scheduler 不关心）**

在“分布式应用运行时操作系统”的语境下，一个**应用调度器**通常需要解决：

- 应用由哪些组件组成？（Service / Worker / Actor / Task DAG）
- 组件之间的**启动顺序、依赖关系、生命周期编排**
- 应用级 QoS（SLA、延迟、吞吐、可用性）
- 应用级弹性策略（Scale Out / Scale In / 灰度 / 回滚）
- 应用整体的资源预算与成本约束
- 应用状态与运行时上下文（Session / Workflow / State）

这些问题具有明显特征：

- 跨 Pod
- 跨 Node
- 跨时间（生命周期、阶段性状态）

> 👉 **Kubernetes Scheduler** **不具备“应用整体视角”**。

### **8.3 调度粒度不匹配：Pod ≠ Application**

Kubernetes Scheduler 的调度对象是：

- 单个 Pod

而在你的目标系统中，调度对象是：

- 一个完整的“应用实例”
- 或一个应用的运行阶段（Phase / Stage）

例如：

- 一个流式计算应用需要先启动 Coordinator，再启动 Workers
- 一个 AI 任务需要 GPU Worker 与 Parameter Server 协同调度
- 一个在线应用需要保证 Web + Cache + DB Proxy 的拓扑一致性

这些都无法用“一个 Pod 放到哪个 Node”来表达。

> 👉 **Pod** **调度是必要条件，但不是充分条件**。

### **8.4 无法表达应用级调度约束**

Kubernetes Scheduler 的约束模型主要是：

- Node 维度约束
- Pod 之间的简单亲和 / 反亲和关系

但应用调度器常见的约束包括：

- "这个应用最多只能占用整个集群 20% 的资源"
- "该应用的副本必须分布在至少 3 个机架"
- "当下游组件未 Ready 时，不允许上游扩容"
- "同一租户的应用之间需要公平调度"

这些约束：

- 无法自然映射到 Pod-Level Scheduling
- 即使勉强实现，也会导致 Scheduler 插件极度复杂

### **8.5 扩展 Kubernetes Scheduler 的代价**

理论上，可以通过：

- Scheduler Framework
- 自定义 Filter / Score 插件

来“增强” Kubernetes Scheduler。

但在工程实践中会遇到：

- 插件逻辑必须在**同步调度路径**中执行，复杂度受限
- 调度器状态主要是 Node / Pod 视角，维护应用状态极其困难
- 与 K8s 内部调度策略强耦合，升级成本高
- 需要深入理解 Scheduler 内部实现细节

👉 **这会把一个应用调度问题，强行塞进一个节点调度器中**。

### **8.6 工业界的通用做法**

工业界通常采用**分层调度（Two-Level Scheduling）**：

- **Kubernetes Scheduler**：
  - 负责 Pod → Node 的映射
  - 提供稳定、通用的资源分配能力
- **上层应用调度器 / 运行时系统**：
  - 决定“是否创建 Pod”
  - 决定“创建多少 Pod”
  - 决定“应用处于哪个运行阶段”

典型案例：

- Spark on Kubernetes
- Ray
- Flink
- Argo Workflows
- Volcano（批处理 / AI 调度）

### **8.7 本系统的定位结论**

因此，在本设计中：

- Kubernetes 被视为：

**分布式资源内核（Distributed Resource Kernel）**

- 本系统承担：

**应用运行时操作系统（Application Runtime OS）**

两者关系为：

本系统通过 Kubernetes 提供的资源抽象运行，但不试图替代 Kubernetes Scheduler，而是在其之上实现应用级调度与运行时管理。

这也是本系统存在的根本技术理由之一。

---

## 9. 多租户与权限模型（Tenant & Isolation Model）

本章定义 D-AROS 在多租户环境下的**资源隔离、裁决优先级与权限边界模型**，用于支撑共享集群中的公平性、可控性与系统安全。

------

### 9.1 设计目标

多租户模型的设计目标是：

- 支持多个租户在同一集群中并发运行应用
- 防止资源争抢导致系统失序
- 明确裁决优先级与干预权限
- 保证调度与生命周期行为**可预测**

> 多租户不是“标签隔离”，而是**裁决与责任的最小边界单元**。

------

### 9.2 Tenant（租户）定义

> **Tenant 是 D-AROS 中资源裁决与权限控制的第一层边界。**

Tenant 表示一个具有**独立资源预算、策略边界与管理权限**的逻辑实体，可能对应：

- 一个业务团队
- 一个项目组
- 一个内部客户
- 一个外部用户组织

------

#### 9.2.1 Tenant 的核心属性

```text
Tenant
├── Quota
│   ├── ResourceQuota
│   ├── ApplicationCount
│   └── PriorityCeiling
├── PolicySet
├── Applications
└── AccessControl
```

------

#### 9.2.2 Tenant 与 Application 的关系

- 每个 Application **必须且只能属于一个 Tenant**
- Tenant 是 Application 参与裁决的**最小隔离域**
- 不允许跨 Tenant 的 Application 合并调度或共享配额

------

### 9.3 资源隔离与裁决优先级

#### 9.3.1 租户级配额（Quota）

Tenant Quota 是 **硬约束**，用于准入与裁决阶段：

- CPU / Memory / Device 总量
- 可同时运行的 Application 数量
- 最大并发 Workload 数量

> 超出 Tenant Quota 的 Application **不会进入调度阶段**。

------

#### 9.3.2 租户优先级模型

- Tenant 可配置一个 **Priority Ceiling**
- Application Priority **不得超过其 Tenant 的 Priority Ceiling**
- 裁决引擎首先在 Tenant 之间做资源裁决，再在 Tenant 内部裁决 Application

```text
Global Resource
   ↓
Tenant Arbitration
   ↓
Application Arbitration
```

------

### 9.4 权限模型（Access Control）

D-AROS 的权限控制遵循最小原则：

| 权限主体          | 可执行操作                 |
| ----------------- | -------------------------- |
| Platform Admin    | 创建 Tenant / 设置全局策略 |
| Tenant Admin      | 管理 Tenant 配额 / 策略    |
| Application Owner | 管理 Application 生命周期  |

明确禁止：

- Application Owner 修改 Tenant 级策略
- Tenant 越权干预其他 Tenant 的 Application

------

### 9.5 多租户模型的系统意义

通过引入 Tenant 作为裁决与隔离的第一层边界，D-AROS 实现了：

- 应用级调度的**可治理性**
- 共享集群环境下的**公平与可控**
- 平台责任与业务责任的**清晰分离**

------

## 10. 策略系统与治理模型（Policy & Governance）

本章定义 D-AROS 中**策略的来源、作用域、生效顺序与治理原则**，用于防止策略失控与系统复杂度膨胀。

------

### 10.1 策略系统的设计目标

- 策略可演进，但机制必须稳定
- 策略作用范围必须明确
- 策略冲突必须有确定性裁决规则

> **策略不是代码逻辑，而是系统约束的一部分。**

------

### 10.2 策略分层模型

D-AROS 定义三层策略域：

```text
Policy
├── Global Policy
├── Tenant Policy
└── Application Policy
```

------

#### 10.2.1 Global Policy（平台级）

- 定义平台级调度原则
- 定义系统安全与稳定性红线
- 由 Platform Team 维护

示例：

- 是否允许抢占
- 最大资源超卖比例
- 全局降级策略

------

#### 10.2.2 Tenant Policy（租户级）

- 定义 Tenant 内 Application 的裁决规则
- 受 Global Policy 约束
- 不得突破平台红线

------

#### 10.2.3 Application Policy（应用级）

- 定义应用自身的生命周期与弹性行为
- 只能在 Tenant Policy 允许范围内生效

------

### 10.3 策略生效顺序与冲突处理

策略裁决遵循以下优先级：

```text
Global Policy
   ↓
Tenant Policy
   ↓
Application Policy
```

冲突处理原则：

- 高层策略优先生效
- 冲突策略直接裁决失败
- 不允许“隐式覆盖”

------

### 10.4 策略与机制的边界约束

明确禁止：

- 策略直接操纵 Runtime
- 策略绕过生命周期系统
- 策略在执行路径中引入强依赖逻辑

> 策略只能影响 **裁决结果**，不能直接产生 **执行动作**。

------

## 11. 控制平面可靠性与状态恢复

本章定义 D-AROS 控制平面的可靠性原则与状态恢复模型。

------

### 11.1 控制平面失败假设

D-AROS 明确假设：

- Control Plane 可能崩溃
- 网络可能分区
- 控制逻辑可能被中断

系统必须在这些条件下保持**状态一致性与可恢复性**。

------

### 11.2 状态持久化模型

- Application Spec 作为期望态，必须持久化
- Application Status 作为裁决结果，必须持久化
- 所有状态变更必须是 **原子、幂等、可重放的**

------

### 11.3 重启与恢复原则

Control Plane 重启后：

- 以持久化状态为唯一事实来源
- 不依赖 Runtime 的瞬时状态
- 通过 Reconciliation Loop 重新驱动系统收敛

------

### 11.4 禁止的行为

- 不允许在内存中维护唯一裁决状态
- 不允许“半完成”的状态迁移
- 不允许跳过生命周期系统进行恢复

------

## 12. 与 CI/CD 与发布系统的关系

本章用于明确 D-AROS 与应用发布、升级、回滚等流程的边界关系。

------

### 12.1 设计边界声明

D-AROS **不是发布系统**，也不负责：

- 镜像构建
- 版本产物生成
- 发布流水线编排

------

### 12.2 D-AROS 的职责

D-AROS 在发布流程中承担：

- 应用版本变更的生命周期建模
- 发布过程中的资源裁决
- 发布阶段的状态一致性保障

------

### 12.3 Application Spec 变更的系统语义

- Spec 变更被视为 **期望态更新**
- 生命周期系统决定是否允许状态推进
- 不允许发布系统绕过生命周期直接修改运行实体

------

## 13. 可观测性与可解释性（Observability & Explainability）

本章定义 D-AROS 的系统可观测性目标，确保系统行为**可理解、可追溯、可解释**。

------

### 13.1 可观测性的设计目标

- 用户能回答：**“发生了什么？”**
- 平台能回答：**“为什么这样裁决？”**
- 系统能回答：**“是否按设计运行？”**

------

### 13.2 关键可观测对象

#### 13.2.1 生命周期事件

- 状态迁移事件
- 准入失败原因
- 降级 / 抢占触发原因

------

#### 13.2.2 裁决结果解释

每一次裁决必须产生：

- 输入约束摘要
- 生效策略列表
- 裁决结果说明

------

### 13.3 系统可信度原则

> **一个无法解释自己行为的调度系统，必然会被绕过或弃用。**

----

## 14. 参考与设计来源

- Kubernetes 官方文档  
  https://kubernetes.io/docs/
- Borg: Large-scale cluster management at Google  
  https://research.google/pubs/pub43438/
- Omega: Flexible, scalable schedulers for large compute clusters  
  https://research.google/pubs/pub41684/
- Apache Mesos  
  https://mesos.apache.org/
- HashiCorp Nomad  
  https://www.nomadproject.io/

---

## 15. 术语表（Glossary）

- **Application**：由多个组件构成、具有整体运行目标的业务单元
- **Cluster OS**：负责节点与资源调度的分布式集群内核（如 Kubernetes）
- **Application Runtime OS**：以应用为中心的运行时控制与裁决系统
- **Arbitration（裁决）**：在多应用、多约束条件下做出的资源与优先级决策
- **Control Plane**：负责决策、状态管理与协调的系统部分
- **Data Plane**：实际承载业务执行的运行实体

---

## 16. 总结

D-AROS 并非重新实现一个分布式内核，而是：

> 将操作系统的设计思想，上移到“分布式应用运行时”这一层级。

其价值在于为复杂应用提供：

- 可预测的运行环境
- 可裁决的资源使用模型
- 可持续演进的系统抽象

