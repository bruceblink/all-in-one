---
sidebar_position: 3
typora-root-url: ./..\..\static
---
# 第 2 章 古老的秘密在现代机器上延续（Ancient secret keeping on modern machines）


本章内容包括：

- 如何建立一个基础的 Haskell 项目并运行代码
- Haskell 常见数据类型与函数的工作原理
- 使用字符串和列表执行基本操作
- 通过守卫（guards）与模式匹配（pattern matching）处理不同情况
- 操作不可变数据并表示数据转换

在上一章中，我们了解了 Haskell 是什么，并讨论了它在语言设计上的一些独特之处。我们还学习了纯函数（pure functions）的特性，以及像 Haskell 这样的纯函数式语言是如何组织程序结构的。
 这些概念固然重要，但光说不练是没有意义的——理论必须结合实践才能真正掌握。现在，是时候动手实现我们的第一个项目了！

学习任何一门编程语言，总得从某处开始。虽然我可以用数学推导或学术练习来“折磨”你，但这本书的主题更轻松一点。有人甚至会说这些内容挺有趣——不过你不一定得这么认为。本章主要介绍 Haskell 的语法以及编写程序的基本方式。由于 Haskell 的核心理念与其他主流语言大相径庭，你最好暂时“忘掉”自己熟悉的一些编程模式。可变变量？静态数据？命令式控制流？——这些概念在我们即将踏入的世界中都是不存在的“黑魔法”。

我知道刚才的比喻有点夸张，所以让我解释一下：Haskell 的纯函数式设计一开始可能会让人望而生畏。如果你之前没有接触过函数式语言，那么本章的概念可能会显得有些奇怪。这主要是因为这种语言的设计思路与我们熟悉的命令式语言截然不同。举个例子，**Haskell 没有循环！** 当然，Haskell 有很多方式可以实现与循环类似的功能。严格来说，我们根本不需要循环——但这也意味着我们必须重新思考许多关于“编程”的旧习惯。

虽然这听起来有些可怕，但这趟旅程非常值得。Haskell 的核心概念是普适的——几乎可以在任何其他语言中实现。学习纯函数式编程的过程，其实是在学习一种全新的思维方式：如何用数学化的思考方式写出正确且可靠的程序。

本章将从建立一个新的 Haskell 项目开始，并使用 Haskell 编译器的交互模式（REPL）来编写与测试原型代码。接着，我们会介绍 Haskell 的多种基本数据类型，以及如何为函数和表达式定义类型。然后我们将学习如何编写函数、操作字符串与列表；进一步，通过守卫和模式匹配深入理解函数的结构与控制逻辑。最后，本章会介绍并使用内置的 **`map`** 函数。


## 2.1 Haskell 入门（A primer on Haskell）

现代计算机系统几乎都依赖外部网络才能高效工作。无论是通过 NTP 或 PTP 进行时间同步、在分布式 NoSQL 数据库中存储数据，还是晚上看一段 4K 猫咪视频——网络无处不在。但这也带来了一个重大问题：**我们必须保护在公共网络中传输的个人数据。**我们不能把自己的银行账户信息对着森林大喊一遍，然后祈祷没人听见。

正如你可能已经猜到的，解决方案就是——**加密（encryption）** 。加密的基本思路是使用一个双方共享的“密钥”来对信息进行编码。如今，密码学（cryptography）已深深融入我们的日常生活，而它的研究领域也在不断发展，提出越来越复杂的算法与协议来实现“安全保密”的目标。

在本章中，我们将实现一种最古老、最简单的加密方法——**凯撒密码（Caesar’s cipher）**。它在现实世界中早已不再安全，但它能很好地帮助我们理解函数式编程的基本原理。

------

### 2.1.1 凯撒密码（Caesar’s cipher）

这个古老的算法是如何工作的呢？凯撒密码通过将字母表中的每个字母按固定偏移量替换成另一个字母来实现加密。也就是说，你可以根据字母在字母表中的位置选择一个新的字母，从而加密原始字母。

你可以把字母表想象成一个轮盘，所有字母按顺序排列成一个圆圈。从某个字母开始，将轮盘旋转一定偏移量，就会得到新的字母。这个概念在图 2.1 中有示意。

> **图 2.1 字母替换轮盘**
>
> ![figure2-1](/img/learn-haskell-by-example/chapter2/figure2-1.png)

通过对信息中的每个字母进行变换，我们就可以对整条信息加密！用于这种变换的偏移量就是算法的**加密密钥**，需要通信双方都知道。在解密时，只需反向执行同样的操作，就可以恢复原始信息。图 2.2 展示了一个例子：一个小信息被加密时使用了偏移量 5。

>**图 2.2 凯撒密码加密示例**
>
>![figure2-2](/img/learn-haskell-by-example/chapter2/figure2-2.png)

如果只加密基本拉丁字母（并且大写字母和小写字母各自使用自己的字母表），会出现一种有趣的对称性：当偏移量为 13 时，加密和解密互相抵消，也就是说可以用完全相同的方法进行加密和解密。这种特殊的凯撒密码称为 **ROT13**，通常用作文字混淆工具，因为实现非常简单。一些编辑器，如 Vim 和 Emacs，甚至内置了 ROT13 功能！

示例：`Vfa’g gung arng?`

⚠️ **警告**
 为了保护你和他人的数据安全，切勿在任何应用程序中使用这种加密方法！

### 2.1.2 新建项目（A new project）

我们先用 **stack** 创建一个新项目。如果你还没有安装 stack，请参考附录 A。工具链安装好后，可以在操作系统中打开命令行。在 macOS 上可以使用 iTerm，Windows 上可能是 cmd，而 Linux 上选择更多样。

然后，进入你希望存放项目的工作目录，并运行以下命令：

```bash
stack new caesar
```

这会创建一个名为 `caesar` 的新目录，其中已经包含了 Haskell 项目的预设结构。

让我们看看 stack 创建的目录结构（见清单 2.1）：

- 它包含一些元信息文件，如 `CHANGELOG.md`、`LICENSE` 和 `README.md`，用于记录变更、授权信息和项目使用说明（如果项目发布的话）。
- `caesar.cabal`、`package.yaml` 和 `stack.yaml` 对配置依赖和编译选项很重要，但在本项目中我们暂时不修改它们。

项目的核心目录是 `app` 和 `src`：

- `app` 目录包含程序的入口模块（`main`），即编译后的可执行文件的起点，就像 C 或 Java 中的 `main` 函数。
- `src` 目录包含库代码，包括所有模块、类型和函数定义，可以作为独立库使用。这样，我们可以在多个可执行文件中复用相同功能，或者将项目编译为库而非可执行文件。
- `test` 目录可以用来存放测试套件，用于测试库和可执行文件的代码（将在第 9 章详细讲解）。

**清单 2.1 新建 stack 项目的目录结构**

```bash
caesar
├── CHANGELOG.md
├── LICENSE
├── README.md
├── Setup.hs
├── app              #1
│     └── Main.hs
├── caesar.cabal
├── package.yaml
├── src     #2
│     └── Lib.hs
├── stack.yaml
└── test        #3
       └── Spec.hs
#1 用于构建可执行文件的模块
#2 用于构建独立库的模块
#3 用于测试库代码的测试套件
```

目前我们唯一需要关注的文件是 `Lib.hs`，将在其中编写函数，并在 Haskell 编译器的交互模式中使用。

------

接下来，我们尝试 **REPL（Read–Eval–Print Loop）** 来熟悉 Haskell 的语法。运行：

```bash
stack repl
```

这会启动 **GHCi**（Glasgow Haskell Compiler 的交互模式），提示符如下：

```bash
ghci>
```

如果当前工作目录是通过 stack 创建的项目，模块和定义会自动加载到 GHCi 中，可以直接测试。

例如，我们尝试一些基本算术：

```haskell
ghci> a = 1 :: Int
ghci> b = 2 :: Int
ghci> c = a + b
ghci> c
3
```

从上面的例子可以看到，我们可以在代码中定义变量，将值与名字关联。REPL 会对每条输入进行求值：赋值语句本身没有结果，而对变量求值则会显示它的值。Haskell 使用 `::` 指明值的类型。

> **注意**
>  在 GHCi 中输入像 `1 + 1` 这样的表达式，会得到结果 2，但可能还会看到关于类型默认的警告。如果不希望看到这些警告，可以使用 `:set -Wno-type-defaults`。

------

接下来我们用函数来实践函数式编程。Haskell 函数的语义与其他语言类似，基本语法很简单：

```haskell
函数名 参数列表 = 函数定义
```

例如：

```haskell
square x = x * x
```

定义了一个单参数函数 `square`，将参数自身相乘。函数调用如下：

```haskell
square 2
```

Haskell 不像其他语言那样使用括号或逗号分隔参数。在 REPL 中输入 `square 2` 会求值并打印结果。

多行输入示例如下：

```haskell
ghci> :{               #1
ghci| square :: Int -> Int
ghci| square x = x * x
ghci| :}       #2
ghci> square 2
4
```

- `:{` 开始多行输入
- `:}` 结束多行输入

为 `square` 指定类型不是必需的，但不写会出现警告。

REPL 适合快速原型和简单测试，但写大函数时可能不太方便。这就是为什么我们会把大部分实现放在 `Lib.hs` 中。

### 2.1.3 第一个模块（The first module）

`Lib.hs` 文件会有一个非常基础的结构，用于展示 Haskell 模块的基本组成。模块包含我们的代码，包括定义和实现，它们帮助我们组织项目，将相关代码分组。

通常模块名必须与文件路径一致（`Main` 模块除外，取决于项目配置）。在这个简单例子中，模块位于 `src` 目录的最高层，因此模块名就是文件名去掉后缀即可。此外，模块可以定义**导出列表**（export list），用来指定哪些定义可以被其他模块访问，因为模块也可以导入其他模块。这个文件可能长这样：

**清单 2.2 stack 创建的简单模块示例**

```haskell
module Lib      --1
    ( someFunc  --2
    ) where

someFunc :: IO ()             --3
someFunc = putStrLn "someFunc"  --4
```

- `--1` 定义模块名
- `--2` 指定导出列表
- `--3` 给出类型签名
- `--4` 提供函数定义

这个模块本身没有实际用途，只是用来演示模块如何构建。我们看到一个名为 `someFunc` 的 IO 操作定义，它被模块名后的导出列表导出。IO 操作的具体内容将在第 3 章讲解，目前我们不需要关注。

------

导入其他模块最基本的方法是使用 `import` 语句。它会导入指定模块的所有导出定义（如果没有导出列表，则导入全部）。这种方式适合导入提供独特函数的工具模块，但有可能出现名字冲突。这时可以在函数名前加上模块名，如 `ModuleName.x` 来指定使用哪个定义。

------

接下来看看 `Main.hs`，了解如何导入 `Lib` 模块以及“主模块”的样子。主模块包含 `main` 操作，是程序的入口。我们暂时不关心 `main` 做什么，只需把它当作一个被调用的函数即可。

**清单 2.3 stack 创建的简单 Main 模块**

```haskell
module Main where
import Lib      --1

main :: IO ()  --2
main = someFunc
```

- `--1` 导入模块
- `--2` 定义主操作

在本项目中，我们所有实现都在 `Lib` 模块，并用 GHCi 测试，因此可以暂时忽略 `Main` 模块。为了让可执行文件能编译通过，并避免 IDE 报错，我们可以把 `Main.hs` 改为只打印 `Hello World`，不再导入 `Lib`：

```haskell
module Main where

main :: IO ()
main = putStrLn "Hello World"
```

------

回到 `Lib.hs`，进一步熟悉 Haskell。我们可以先删除导出列表和 `someFunc`，模块就变成：

```haskell
module Lib where
```

干净整洁——一个全新的开始！我们可以在这个模块中定义函数，而不必在 GHCi 中逐行输入。

定义函数后，需要把它加入导出列表，这样其他模块才能访问：

```haskell
module Lib
  ( square,
  )
where

square :: Int -> Int
square x = x * x
```

保存文件后，就可以加载模块了。方法是进入项目目录，运行：

```bash
stack repl
```

> **注意**
>  记得把希望被其他模块访问的函数和类型加入导出列表，否则模块外无法找到它们。虽然可以省略导出列表导出所有定义，但这被认为是不良编码风格，会导致代码难以管理。

模块会自动加载。之后，你就可以在新打开的 GHCi 中使用这些函数。请保持这个 GHCi 会话打开，因为我们将用它进行原型开发。



## 2.2 常见类型与奇妙函数（Typical types and fantastic functions）

为了让我们的项目结构更清晰，我们首先要思考要处理的数据类型。更确切地说，就是要考虑**数据的类型（types）**。在 Haskell 这样的语言中，类型至关重要。与一些其他语言类似，Haskell 是**静态类型语言（statically typed）**——类型在编译时就已经确定，运行时不能动态改变。也就是说，一旦变量拥有某种类型，在程序执行期间这个类型就不会变化。此外，Haskell 还使用**类型推导（type inference）**。如果没有显式地写出类型，Haskell 会尝试根据上下文自动推导类型。通常这种机制非常可靠，不过在某些情况下，我们需要显式地告诉 Haskell 某个表达式或变量的类型。正因为有类型推导机制，我们之前在 GHCi 中输入的那些函数定义，即使没写类型声明，也能正常工作。

然而，**良好的编程风格**是：在模块的顶层定义（top-level definitions）中，显式地写出类型声明。这可以通过**类型表达式（type expression）** 来实现。最基本的形式如下：

```haskell
name :: type
```

它表示给某个名称（或称标识符）分配一个类型。名称只是值的一个映射，因此这实际上是在声明某个值应该具有什么类型。通常类型表达式会紧跟着具体的定义，尽管这不是强制要求。类型表达式是程序中**语义表达式（semantic expressions）**的一个有趣补充。我们已经见过语义表达式，例如 `x * x`。在求值时，这个表达式会产生一个值。如果一个语义表达式带有类型表达式，这意味着**产生的值具有该类型表达式指定的类型**，而不是“语义表达式本身”的类型。稍后在研究函数时，我们会更清楚地看到这种区别。

------

### 2.2.1 原子级别的类型（Types on the atomic level）

了解了类型表达式的基本语法后，我们再看看类型的实际样子。最简单的类型就是**原子类型（atomic types）**，它们是程序中最常用的类型。表 2.1 列出了一些常见的原子类型。

| 名称 (Name) | 描述 (Description) | 示例 (Examples)       |
| ----------- | ------------------ | --------------------- |
| **Bool**    | 布尔真值           | `True`, `False`       |
| **Char**    | Unicode 字符       | `'a'`, `'A'`, `'1'`   |
| **Integer** | 任意精度整数       | `-1`, `9999999`       |
| **Int**     | 固定精度整数       | `-1`, `10`            |
| **Float**   | 单精度浮点数       | `3.1415`, `-1`, `1e2` |
| **Double**  | 双精度浮点数       | `1e-2`, `9.99999`     |

可以看到，一些数值类型的示例值看起来是相同的。当我们使用这些“模棱两可”的值时，Haskell 的类型推导机制就会介入，尝试推断正确的类型。

有了这些类型知识后，我们可以开始思考如何实现加密轮的旋转（见图 2.3）。每一次轮盘旋转都是从一个字母移动到下一个字母的离散步骤，因此**加密密钥**可以简单地表示为一个 `Int`。消息由字母组成，因此是若干 `Char` 值的集合。我们要编写的函数将主要处理这些类型。

> ![figure2-3](/img/learn-haskell-by-example/chapter2/figure2-3.png)
>
> 图 2.3 字母替换轮 

需要特别注意的一点是：**这些原子类型本身也是类型表达式！**这意味着我们可以给出一个属于该类型的值（或语义表达式），形式如下：

```haskell
kilo :: Int
kilo = 1000

mega :: Int
mega = kilo ^ (2 :: Int)

nano :: Double
nano = 1e-9
```

在这里，我们定义了三个表示单位前缀的值。

- 我们将标识符 `kilo` 声明为类型 `Int`，这就明确指定了它是一个整数。
- 而 `nano` 是一个类型为 `Double` 的浮点数。
- `mega` 的定义通过对 `kilo` 进行运算（即指数运算 `^`）得到，因此它必须与 `kilo` 具有相同的类型。

这是因为数值运算符通常**接受并返回相同类型的值**。

### 2.2.2 列表与元组（Lists and tuples）

仅仅依靠简单的原子类型，还不足以构建有用的数据结构。在我们的例子中，我们需要某种方式来表示**一组字母的集合**。幸运的是，Haskell 提供了一些更复杂的类型，本节我们将详细介绍它们。

第一个要介绍的就是 **列表**。列表是 Haskell（以及许多其他函数式编程语言）的核心构建块之一。它的概念非常简单：**列表是一个同质（homogeneous）的值序列**，也就是说，列表中的所有元素必须具有相同的类型。我们可以通过**用方括号包裹的逗号分隔值**来定义列表。列表没有固定长度，可以动态增长。示例如下：

```haskell
intList :: [Int]
intList = [1, 2, 3]

boolList :: [Bool]
boolList = [True]

floatList :: [Float]
floatList = []

doubleList :: [Double]
doubleList = [1, 1 + 1, 1 + 2]
```

列表的类型表达式通过在方括号中包裹另一种类型表达式来表示。由于列表的所有元素都必须是同一类型，方括号中的类型表达式就代表列表内部元素的类型。列表中的所有值（或能产生值的表达式）都必须属于这个类型。在上述例子中，即使是一个空列表（例如 `floatList`），也具有一个确定的类型。列表的类型告诉我们：**该列表中元素的类型是什么**，但它并**不保证列表中一定存在元素**。在 `doubleList` 的例子中，我们甚至可以看到列表中包含的是一些**表达式**（如 `1 + 2`），这些表达式在求值后会变成 `Double` 类型的值。这里我们还能看到 **Haskell 的类型推导机制**在起作用。`doubleList` 可以直接在 Haskell 程序中使用，编译器会自动推断出其中所有元素都是 `Double` 类型。但问题是：`1` 这个字面值也可能是 `Int` 类型呀？Haskell 为什么会知道它是 `Double` 呢？答案是：**因为列表的类型被指定为 `[Double]`**！Haskell 因此知道列表中的所有值都必须是 `Double` 类型。

列表是函数式编程语言的“主食”数据类型。例如 **ML**、**Lisp**（“list interpreter”的缩写）以及它们的衍生语言，都以列表作为核心数据结构之一。因此，学习 Haskell 中的列表，也能帮助你在许多其他语言（包括非函数式语言）中理解类似的概念。

另一种重要的数据类型是 **元组**。它与列表类似，都是一组值的序列，但有两个显著区别：

1. **元组的长度是固定的**。
2. **元组中的元素可以有不同的类型**。

元组的写法是：**逗号分隔的值放在圆括号中**。类型表达式的写法与值表达式类似，就像列表那样：

```haskell
intPair :: (Int, Int)
intPair = (0, 1)

intFloatPair :: (Int, Float)
intFloatPair = (0, 1)

intCharDoubleTriple :: (Int, Char, Double)
intCharDoubleTriple = (1, 'a', 2)

septuple :: (Int, Float, Int, Float, Int, Float, Char)
septuple = (1, 1, 1, 1, 1, 1, 'a')
```

从这些例子中可以看到，我们可以将不同类型的值组合在一起形成复杂的类型。元组的长度可以任意（至少两个元素），而且不要求所有元素是同一类型。这种类型在需要**将不同数据建立关联**时非常有用，比如将一个整数与一个字符或浮点数配对存储。

### 2.2.3 函数类型（Function types）

现在我们来看最后一种（也许是最重要的）数据类型：**函数**。没错，函数本身就是一种数据类型！不仅如此，**函数在 Haskell 中也是值（value）**。到目前为止，我们主要编写的是一些基本的、主要是数值类型的表达式和值。但我们还没有真正解释，为什么之前定义的 `square` 实际上会变成一个可执行的函数。本质上，我们创建了一个**值**，并将它与名称 `square` 关联起来。

#### 匿名函数（Anonymous functions）

首先，我们来看如何在不命名的情况下定义一个函数。这样的函数被称为 **匿名函数（anonymous function）**。在 Haskell 中，它们通过所谓的 **lambda 抽象（lambda abstraction）** 表示，形式如下：

```haskell
\x -> x * x
```

这其实就是我们之前的平方函数。它接受一个参数 `x`，并产生表达式 `x * x` 的结果。我们也可以把这个函数值绑定到一个名字上：

```haskell
square = \x -> x * x
```

这样，我们就得到了之前的 `square` 函数。它其实与我们原先的定义完全相同，只是写法不同而已。让我们看看这个值的类型：

```haskell
square :: Int -> Int
square = \x -> x * x
```

可以看到，**类型表达式的形式几乎与函数定义本身相似**。就像函数把变量（例如 `x`）映射到某个表达式（如 `x * x`），类型表达式也说明了函数是如何将一个类型映射到另一个类型的。这里的意思是：`square` 接受一个 `Int`，返回另一个 `Int`。

这就是一个**一元函数（unary function）**的类型表达式——它只接受一个参数。

#### 多参数函数（Curried function）

我们再看看如何定义一个**二元函数**（接受两个参数的函数）：

```haskell
add :: Int -> Int -> Int
add = \x -> \y -> x + y
```

在 Haskell 中，如果一个函数接收一个变量并返回一个表达式，那么这个表达式也可以是一个函数！我们可以通过在“内层”函数外加括号来更清晰地看到这一点：

```haskell
add :: Int -> (Int -> Int)
add = \x -> (\y -> x + y)
```

不过这种写法显得既啰嗦又难读，所以 Haskell 提供了**语法糖（syntactic sugar）**，让我们能更简洁地书写函数：

```haskell
add :: Int -> Int -> Int
add = \x y -> x + y
```

我们看到，现在的 lambda 抽象一次性接受两个参数。甚至我们还可以再进一步简化——直接把参数写在函数名后面：

```haskell
add :: Int -> Int -> Int
add x y = x + y
```

这就是我们在 Haskell 中最常用的函数定义方式。可以看出，lambda 抽象中的参数可以“移”到函数名后面。在许多其他语言中，函数的类型通常写作**参数类型 + 返回类型**的组合。Haskell 的函数类型表达式其实也可以这样理解：前面的类型代表参数类型，而最后一个类型代表函数**“返回值”**的类型。这一点在 **图 2.4** 中有清楚的示意。不过这里的 “return” 一词被特意加上了引号。这是因为在函数式编程中，**我们不应把函数理解为“返回”某个值**——函数**只是被求值（evaluated）为某个值**。

> ![figure2-4](/img/learn-haskell-by-example/chapter2/figure2-4.png)
>
> 图 2.4：一个函数的类型表达式示例及其对应的定义