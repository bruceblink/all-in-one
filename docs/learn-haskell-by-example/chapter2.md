---
sidebar_position: 3
typora-root-url: ./..\..\static
---
# 第 2 章 古老的秘密在现代机器上延续（Ancient secret keeping on modern machines）


本章内容包括：

- 如何建立一个基础的 Haskell 项目并运行代码
- Haskell 常见数据类型与函数的工作原理
- 使用字符串和列表执行基本操作
- 通过守卫（guards）与模式匹配（pattern matching）处理不同情况
- 操作不可变数据并表示数据转换

在上一章中，我们了解了 Haskell 是什么，并讨论了它在语言设计上的一些独特之处。我们还学习了纯函数（pure functions）的特性，以及像 Haskell 这样的纯函数式语言是如何组织程序结构的。
 这些概念固然重要，但光说不练是没有意义的——理论必须结合实践才能真正掌握。现在，是时候动手实现我们的第一个项目了！

学习任何一门编程语言，总得从某处开始。虽然我可以用数学推导或学术练习来“折磨”你，但这本书的主题更轻松一点。有人甚至会说这些内容挺有趣——不过你不一定得这么认为。本章主要介绍 Haskell 的语法以及编写程序的基本方式。由于 Haskell 的核心理念与其他主流语言大相径庭，你最好暂时“忘掉”自己熟悉的一些编程模式。可变变量？静态数据？命令式控制流？——这些概念在我们即将踏入的世界中都是不存在的“黑魔法”。

我知道刚才的比喻有点夸张，所以让我解释一下：Haskell 的纯函数式设计一开始可能会让人望而生畏。如果你之前没有接触过函数式语言，那么本章的概念可能会显得有些奇怪。这主要是因为这种语言的设计思路与我们熟悉的命令式语言截然不同。举个例子，**Haskell 没有循环！** 当然，Haskell 有很多方式可以实现与循环类似的功能。严格来说，我们根本不需要循环——但这也意味着我们必须重新思考许多关于“编程”的旧习惯。

虽然这听起来有些可怕，但这趟旅程非常值得。Haskell 的核心概念是普适的——几乎可以在任何其他语言中实现。学习纯函数式编程的过程，其实是在学习一种全新的思维方式：如何用数学化的思考方式写出正确且可靠的程序。

本章将从建立一个新的 Haskell 项目开始，并使用 Haskell 编译器的交互模式（REPL）来编写与测试原型代码。接着，我们会介绍 Haskell 的多种基本数据类型，以及如何为函数和表达式定义类型。然后我们将学习如何编写函数、操作字符串与列表；进一步，通过守卫和模式匹配深入理解函数的结构与控制逻辑。最后，本章会介绍并使用内置的 **`map`** 函数。


## 2.1 Haskell 入门（A primer on Haskell）

现代计算机系统几乎都依赖外部网络才能高效工作。无论是通过 NTP 或 PTP 进行时间同步、在分布式 NoSQL 数据库中存储数据，还是晚上看一段 4K 猫咪视频——网络无处不在。但这也带来了一个重大问题：**我们必须保护在公共网络中传输的个人数据。**我们不能把自己的银行账户信息对着森林大喊一遍，然后祈祷没人听见。

正如你可能已经猜到的，解决方案就是——**加密（encryption）** 。加密的基本思路是使用一个双方共享的“密钥”来对信息进行编码。如今，密码学（cryptography）已深深融入我们的日常生活，而它的研究领域也在不断发展，提出越来越复杂的算法与协议来实现“安全保密”的目标。

在本章中，我们将实现一种最古老、最简单的加密方法——**凯撒密码（Caesar’s cipher）**。它在现实世界中早已不再安全，但它能很好地帮助我们理解函数式编程的基本原理。

------

### 2.1.1 凯撒密码（Caesar’s cipher）

这个古老的算法是如何工作的呢？凯撒密码通过将字母表中的每个字母按固定偏移量替换成另一个字母来实现加密。也就是说，你可以根据字母在字母表中的位置选择一个新的字母，从而加密原始字母。

你可以把字母表想象成一个轮盘，所有字母按顺序排列成一个圆圈。从某个字母开始，将轮盘旋转一定偏移量，就会得到新的字母。这个概念在图 2.1 中有示意。

> **图 2.1 字母替换轮盘**
>
> ![figure2-1](/img/learn-haskell-by-example/chapter2/figure2-1.png)

通过对信息中的每个字母进行变换，我们就可以对整条信息加密！用于这种变换的偏移量就是算法的**加密密钥**，需要通信双方都知道。在解密时，只需反向执行同样的操作，就可以恢复原始信息。图 2.2 展示了一个例子：一个小信息被加密时使用了偏移量 5。

>**图 2.2 凯撒密码加密示例**
>
>![figure2-2](/img/learn-haskell-by-example/chapter2/figure2-2.png)

如果只加密基本拉丁字母（并且大写字母和小写字母各自使用自己的字母表），会出现一种有趣的对称性：当偏移量为 13 时，加密和解密互相抵消，也就是说可以用完全相同的方法进行加密和解密。这种特殊的凯撒密码称为 **ROT13**，通常用作文字混淆工具，因为实现非常简单。一些编辑器，如 Vim 和 Emacs，甚至内置了 ROT13 功能！

示例：`Vfa’g gung arng?`

⚠️ **警告**
 为了保护你和他人的数据安全，切勿在任何应用程序中使用这种加密方法！

### 2.1.2 新建项目（A new project）

我们先用 **stack** 创建一个新项目。如果你还没有安装 stack，请参考附录 A。工具链安装好后，可以在操作系统中打开命令行。在 macOS 上可以使用 iTerm，Windows 上可能是 cmd，而 Linux 上选择更多样。

然后，进入你希望存放项目的工作目录，并运行以下命令：

```bash
stack new caesar
```

这会创建一个名为 `caesar` 的新目录，其中已经包含了 Haskell 项目的预设结构。

让我们看看 stack 创建的目录结构（见清单 2.1）：

- 它包含一些元信息文件，如 `CHANGELOG.md`、`LICENSE` 和 `README.md`，用于记录变更、授权信息和项目使用说明（如果项目发布的话）。
- `caesar.cabal`、`package.yaml` 和 `stack.yaml` 对配置依赖和编译选项很重要，但在本项目中我们暂时不修改它们。

项目的核心目录是 `app` 和 `src`：

- `app` 目录包含程序的入口模块（`main`），即编译后的可执行文件的起点，就像 C 或 Java 中的 `main` 函数。
- `src` 目录包含库代码，包括所有模块、类型和函数定义，可以作为独立库使用。这样，我们可以在多个可执行文件中复用相同功能，或者将项目编译为库而非可执行文件。
- `test` 目录可以用来存放测试套件，用于测试库和可执行文件的代码（将在第 9 章详细讲解）。

**清单 2.1 新建 stack 项目的目录结构**

```bash
caesar
├── CHANGELOG.md
├── LICENSE
├── README.md
├── Setup.hs
├── app              #1
│     └── Main.hs
├── caesar.cabal
├── package.yaml
├── src     #2
│     └── Lib.hs
├── stack.yaml
└── test        #3
       └── Spec.hs
#1 用于构建可执行文件的模块
#2 用于构建独立库的模块
#3 用于测试库代码的测试套件
```

目前我们唯一需要关注的文件是 `Lib.hs`，将在其中编写函数，并在 Haskell 编译器的交互模式中使用。

------

接下来，我们尝试 **REPL（Read–Eval–Print Loop）** 来熟悉 Haskell 的语法。运行：

```bash
stack repl
```

这会启动 **GHCi**（Glasgow Haskell Compiler 的交互模式），提示符如下：

```bash
ghci>
```

如果当前工作目录是通过 stack 创建的项目，模块和定义会自动加载到 GHCi 中，可以直接测试。

例如，我们尝试一些基本算术：

```haskell
ghci> a = 1 :: Int
ghci> b = 2 :: Int
ghci> c = a + b
ghci> c
3
```

从上面的例子可以看到，我们可以在代码中定义变量，将值与名字关联。REPL 会对每条输入进行求值：赋值语句本身没有结果，而对变量求值则会显示它的值。Haskell 使用 `::` 指明值的类型。

> **注意**
>  在 GHCi 中输入像 `1 + 1` 这样的表达式，会得到结果 2，但可能还会看到关于类型默认的警告。如果不希望看到这些警告，可以使用 `:set -Wno-type-defaults`。

------

接下来我们用函数来实践函数式编程。Haskell 函数的语义与其他语言类似，基本语法很简单：

```haskell
函数名 参数列表 = 函数定义
```

例如：

```haskell
square x = x * x
```

定义了一个单参数函数 `square`，将参数自身相乘。函数调用如下：

```haskell
square 2
```

Haskell 不像其他语言那样使用括号或逗号分隔参数。在 REPL 中输入 `square 2` 会求值并打印结果。

多行输入示例如下：

```haskell
ghci> :{               #1
ghci| square :: Int -> Int
ghci| square x = x * x
ghci| :}       #2
ghci> square 2
4
```

- `:{` 开始多行输入
- `:}` 结束多行输入

为 `square` 指定类型不是必需的，但不写会出现警告。

REPL 适合快速原型和简单测试，但写大函数时可能不太方便。这就是为什么我们会把大部分实现放在 `Lib.hs` 中。

### 2.1.3 第一个模块（The first module）

`Lib.hs` 文件会有一个非常基础的结构，用于展示 Haskell 模块的基本组成。模块包含我们的代码，包括定义和实现，它们帮助我们组织项目，将相关代码分组。

通常模块名必须与文件路径一致（`Main` 模块除外，取决于项目配置）。在这个简单例子中，模块位于 `src` 目录的最高层，因此模块名就是文件名去掉后缀即可。此外，模块可以定义**导出列表**（export list），用来指定哪些定义可以被其他模块访问，因为模块也可以导入其他模块。这个文件可能长这样：

**清单 2.2 stack 创建的简单模块示例**

```haskell
module Lib      --1
    ( someFunc  --2
    ) where

someFunc :: IO ()             --3
someFunc = putStrLn "someFunc"  --4
```

- `--1` 定义模块名
- `--2` 指定导出列表
- `--3` 给出类型签名
- `--4` 提供函数定义

这个模块本身没有实际用途，只是用来演示模块如何构建。我们看到一个名为 `someFunc` 的 IO 操作定义，它被模块名后的导出列表导出。IO 操作的具体内容将在第 3 章讲解，目前我们不需要关注。

------

导入其他模块最基本的方法是使用 `import` 语句。它会导入指定模块的所有导出定义（如果没有导出列表，则导入全部）。这种方式适合导入提供独特函数的工具模块，但有可能出现名字冲突。这时可以在函数名前加上模块名，如 `ModuleName.x` 来指定使用哪个定义。

------

接下来看看 `Main.hs`，了解如何导入 `Lib` 模块以及“主模块”的样子。主模块包含 `main` 操作，是程序的入口。我们暂时不关心 `main` 做什么，只需把它当作一个被调用的函数即可。

**清单 2.3 stack 创建的简单 Main 模块**

```haskell
module Main where
import Lib      --1

main :: IO ()  --2
main = someFunc
```

- `--1` 导入模块
- `--2` 定义主操作

在本项目中，我们所有实现都在 `Lib` 模块，并用 GHCi 测试，因此可以暂时忽略 `Main` 模块。为了让可执行文件能编译通过，并避免 IDE 报错，我们可以把 `Main.hs` 改为只打印 `Hello World`，不再导入 `Lib`：

```haskell
module Main where

main :: IO ()
main = putStrLn "Hello World"
```

------

回到 `Lib.hs`，进一步熟悉 Haskell。我们可以先删除导出列表和 `someFunc`，模块就变成：

```haskell
module Lib where
```

干净整洁——一个全新的开始！我们可以在这个模块中定义函数，而不必在 GHCi 中逐行输入。

定义函数后，需要把它加入导出列表，这样其他模块才能访问：

```haskell
module Lib
  ( square,
  )
where

square :: Int -> Int
square x = x * x
```

保存文件后，就可以加载模块了。方法是进入项目目录，运行：

```bash
stack repl
```

> **注意**
>  记得把希望被其他模块访问的函数和类型加入导出列表，否则模块外无法找到它们。虽然可以省略导出列表导出所有定义，但这被认为是不良编码风格，会导致代码难以管理。

模块会自动加载。之后，你就可以在新打开的 GHCi 中使用这些函数。请保持这个 GHCi 会话打开，因为我们将用它进行原型开发。