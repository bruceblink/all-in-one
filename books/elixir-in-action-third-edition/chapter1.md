---
sidebar_position: 6
typora-root-url: ./..\..\static
---

# 第 1 章 第一步（First steps）

本章涵盖内容  
- Erlang概览  
- Elixir的优势  

这标志着您正式开启Elixir与Erlang世界的探索之旅。这两项高效实用的技术能极大简化大规模可扩展系统的开发。您阅读本书大概率是为了学习Elixir，但由于Elixir构建于Erlang之上并深度依赖其底层机制，我们首先需要了解Erlang的核心价值。让我们先对Erlang进行高层次的整体性观察。

## **1.1 关于Erlang**（About Erlang）

Erlang是用于构建可扩展、高可靠性系统的开发平台，其设计目标是实现近乎永不停机的持续服务。这个宣言或许显得大胆，却正是Erlang诞生的初衷。20世纪80年代中期，瑞典电信巨头爱立信为满足其电信系统对可靠性、响应能力、可扩展性与持续可用性的严苛要求，孕育了Erlang技术。电话网络必须确保无论并发通话量如何波动、突发故障何时出现，抑或软硬件升级如何进行，服务都永不停歇。

尽管脱胎于电信领域，Erlang绝非该领域的专用工具。它并未内置对电话设备、交换机等电信硬件的编程支持，而是作为一个通用开发平台，专门为解决并发性、可扩展性、容错性、分布式部署与高可用性等技术性非功能性挑战提供支撑。

回溯20世纪80年代末至90年代初，当多数软件还局限于桌面应用时，高可用性需求仅存于电信等特定系统。如今互联网与网络应用已成为主流，绝大多数系统依赖服务端处理请求、运算数据并向海量客户端推送信息。现代主流系统——无论是社交网络、内容管理系统、按需多媒体服务还是多人在线游戏——都侧重于通信与协作，它们共享着以下非功能性需求：系统必须在任意客户端连接量下保持响应；突发错误的影响必须最小化，绝不能波及整个系统；个别请求因故障失败尚可接受，但系统整体瘫痪则构成严重事故；理想情况下系统应当永不崩溃，甚至能在软件升级时保持运行，始终为客户端提供不间断服务。

这些目标看似艰巨，却是构建可信赖系统的必然要求。响应迟缓或可靠性不足的系统终将失去存在价值。因此，构建服务端系统时，保障持续可用性至关重要——而这正是Erlang的设计使命。它通过可扩展性、容错性与分布式等技术理念直接支撑高可用性实现。与多数现代开发平台不同，这些理念是Erlang发展的核心驱动力。在乔·阿姆斯特朗带领的爱立信团队历经多年设计、原型验证与实践后，该平台在90年代初虽应用有限，但如今几乎所有系统都能从中获益。

近年来Erlang重获瞩目，已持续三十年为各类大型系统提供支持：从WhatsApp即时通讯、Discord聊天平台、RabbitMQ消息队列，到金融系统与多人在线游戏后端，其技术价值已在时间与规模的维度上得到充分验证。但Erlang的魔力究竟何在？让我们解析它如何助力构建高可用性系统。

### **1.1.1 高可用性**（High availability）

Erlang专为支撑高可用性系统而生——这类系统能始终保持在线，即使在突发状况下仍持续为客户提供服务。表面看来简单，但实际生产中隐患无处不在。要实现系统7×24小时不间断运行，必须攻克以下技术挑战：

- **容错性**（**Fault tolerance**）——当不可预见的问题发生时系统必须持续运行。无论是突发错误、潜在漏洞、组件偶发故障、网络连接中断，还是运行主机彻底崩溃，都需要尽可能将错误影响局部化，实现故障恢复，保障系统持续服务。  
- **可扩展性**（**Scalability**）——系统需能应对任意量级负载。当然无需为"全球用户可能涌入"的极端假设过度配置硬件，但应能在不修改软件的前提下，仅通过增加硬件资源来响应负载增长，理想情况下甚至无需重启系统。  
- **分布式部署**（**Distribution**）——要构建永不停止的系统，必须实现多机集群运行。这既提升系统整体稳定性（单机下线时其他节点可接管），又为水平扩展提供可能：通过增加机器来应对负载增长，扩充工作单元以满足更高需求。  
- **响应能力**（**Responsiveness**）——系统必须始终保持合理速度与响应性。即使负载激增或突发错误，请求处理也不应严重延迟。特别需要注意的是，偶发的长时任务绝不能阻塞系统其他部分或显著影响整体性能。  
- **实时更新**（**Live update**）——某些场景下需要在不重启服务的情况下部署新版本软件。例如电话系统进行软件升级时，必须确保已建立的通话不被中断。

若能成功应对这些挑战，系统将成为真正的高可用性系统，无论晴雨皆能为用户提供持续服务。而Erlang正是为解决这些挑战而生——它提供了一系列工具来应对这些难题。通过Erlang并发模型的力量，系统能够获得所有这些特性，最终实现高可用性的终极目标。接下来让我们深入解析Erlang的并发运行机制。

### **1.1.2 Erlang并发模型**（Erlang concurrency）

并发性是Erlang系统的核心与灵魂。几乎所有基于Erlang的复杂生产系统都是高度并发的，以至于这门编程语言有时被称为"面向并发的语言"。如图1.1所示，Erlang没有依赖重量级的操作系统线程或进程，而是将并发控制权掌握在自己手中。

![figure-1-1](/img/elixir-in-action-3-edition/chapter1/figure-1-1.png)

其基本的并发原语称为**Erlang（轻量）进程**（注意区别于操作系统的进程或线程）。典型的Erlang系统会运行成千上万个，甚至数百万个这样的进程。Erlang虚拟机（称为Bogdan/Björn的Erlang抽象机，简称BEAM）使用自身的调度器，在可用的CPU核心间分配进程的执行，从而尽可能地实现并行化。这种进程的实现方式带来了诸多优势：

**容错性**（**FAULT TOLERANCE**）
Erlang进程彼此完全隔离。它们不共享内存，一个进程的崩溃不会导致其他进程崩溃。这有助于将意外错误的影响隔离在局部。即使发生严重问题，其影响范围也仅限于单个进程。此外，Erlang提供了检测进程崩溃并采取补救措施（通常是重启一个新进程来替代崩溃的进程）的机制。

**可扩展性**（**SCALABILITY**）
由于不共享内存，进程之间通过**异步消息**进行通信。这意味着没有复杂的同步机制（如锁、互斥量或信号量）。因此，开发人员可以更简单、更清晰地理解和实现并发实体之间的交互。

典型的Erlang系统被划分为大量并发进程，这些进程相互协作以提供完整的服务。虚拟机能够尽可能高效地将这些进程的执行并行化。因为它们可以利用所有可用的CPU核心，所以Erlang系统具有良好的可扩展性。

**分布式能力**（**DISTRIBUTION**）
无论进程是驻留在同一个BEAM实例中，还是分散在两台独立远程计算机的两个不同实例上，它们之间的通信机制是完全相同的。因此，一个典型的高度并发的、基于Erlang的系统天生就具备跨多台机器分布式部署的能力。这使得系统能够进行**横向扩展**——通过运行一个机器集群来分担总体的系统负载。此外，在多台机器上运行也使系统真正具备了弹性：如果一台机器崩溃，其他机器可以接管其工作。

**响应能力**（**RESPONSIVENESS**）
Erlang运行时环境经过专门调优，以提升系统的整体响应性。如前所述，Erlang通过使用专门的调度器来交替执行大量Erlang进程，从而将多个进程的执行管理权掌握在自己手中。调度器是**抢占式**的——它给予每个进程一个小的执行时间片，然后暂停该进程并运行另一个进程。由于执行时间片很短，单个长时间运行的进程不会阻塞系统的其余部分。此外，I/O操作在内部被委托给单独的线程处理；如果底层操作系统支持，还会利用其内核轮询服务。这意味着任何等待I/O操作完成的进程都不会阻塞其他进程的执行。

甚至垃圾回收机制也经过专门调优，以提升系统响应性。请记住，进程是完全隔离且不共享内存的。这使得**按进程进行垃圾回收**成为可能：无需停止整个系统，每个进程可以根据需要单独进行垃圾回收。这样的回收过程更快速，不会长时间阻塞整个系统。事实上，在多核系统中，完全可能一个CPU核心在进行短暂的垃圾回收，而其他核心仍在正常处理任务。

由此可见，并发性在Erlang中是一个至关重要的元素，其意义远超单纯的并行执行。得益于其底层实现，并发性有力地促进了系统的容错能力、分布式部署和整体响应性。典型的Erlang系统运行着许多并发任务，使用成千上万甚至数百万个进程。这在开发服务端系统时尤其有用，而这些系统往往可以完全用Erlang来实现。