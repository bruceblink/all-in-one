---
sidebar_position: 6
typora-root-url: ./..\..\static
---

# 第 1 章 第一步（First steps）

本章涵盖内容  
- Erlang概览  
- Elixir的优势  

这标志着您正式开启Elixir与Erlang世界的探索之旅。这两项高效实用的技术能极大简化大规模可扩展系统的开发。您阅读本书大概率是为了学习Elixir，但由于Elixir构建于Erlang之上并深度依赖其底层机制，我们首先需要了解Erlang的核心价值。让我们先对Erlang进行高层次的整体性观察。

## **1.1 关于Erlang**（About Erlang）

Erlang是用于构建可扩展、高可靠性系统的开发平台，其设计目标是实现近乎永不停机的持续服务。这个宣言或许显得大胆，却正是Erlang诞生的初衷。20世纪80年代中期，瑞典电信巨头爱立信为满足其电信系统对可靠性、响应能力、可扩展性与持续可用性的严苛要求，孕育了Erlang技术。电话网络必须确保无论并发通话量如何波动、突发故障何时出现，抑或软硬件升级如何进行，服务都永不停歇。

尽管脱胎于电信领域，Erlang绝非该领域的专用工具。它并未内置对电话设备、交换机等电信硬件的编程支持，而是作为一个通用开发平台，专门为解决并发性、可扩展性、容错性、分布式部署与高可用性等技术性非功能性挑战提供支撑。

回溯20世纪80年代末至90年代初，当多数软件还局限于桌面应用时，高可用性需求仅存于电信等特定系统。如今互联网与网络应用已成为主流，绝大多数系统依赖服务端处理请求、运算数据并向海量客户端推送信息。现代主流系统——无论是社交网络、内容管理系统、按需多媒体服务还是多人在线游戏——都侧重于通信与协作，它们共享着以下非功能性需求：系统必须在任意客户端连接量下保持响应；突发错误的影响必须最小化，绝不能波及整个系统；个别请求因故障失败尚可接受，但系统整体瘫痪则构成严重事故；理想情况下系统应当永不崩溃，甚至能在软件升级时保持运行，始终为客户端提供不间断服务。

这些目标看似艰巨，却是构建可信赖系统的必然要求。响应迟缓或可靠性不足的系统终将失去存在价值。因此，构建服务端系统时，保障持续可用性至关重要——而这正是Erlang的设计使命。它通过可扩展性、容错性与分布式等技术理念直接支撑高可用性实现。与多数现代开发平台不同，这些理念是Erlang发展的核心驱动力。在乔·阿姆斯特朗带领的爱立信团队历经多年设计、原型验证与实践后，该平台在90年代初虽应用有限，但如今几乎所有系统都能从中获益。

近年来Erlang重获瞩目，已持续三十年为各类大型系统提供支持：从WhatsApp即时通讯、Discord聊天平台、RabbitMQ消息队列，到金融系统与多人在线游戏后端，其技术价值已在时间与规模的维度上得到充分验证。但Erlang的魔力究竟何在？让我们解析它如何助力构建高可用性系统。

### **1.1.1 高可用性**（High availability）

Erlang专为支撑高可用性系统而生——这类系统能始终保持在线，即使在突发状况下仍持续为客户提供服务。表面看来简单，但实际生产中隐患无处不在。要实现系统7×24小时不间断运行，必须攻克以下技术挑战：

- **容错性**（**Fault tolerance**）——当不可预见的问题发生时系统必须持续运行。无论是突发错误、潜在漏洞、组件偶发故障、网络连接中断，还是运行主机彻底崩溃，都需要尽可能将错误影响局部化，实现故障恢复，保障系统持续服务。  
- **可扩展性**（**Scalability**）——系统需能应对任意量级负载。当然无需为"全球用户可能涌入"的极端假设过度配置硬件，但应能在不修改软件的前提下，仅通过增加硬件资源来响应负载增长，理想情况下甚至无需重启系统。  
- **分布式部署**（**Distribution**）——要构建永不停止的系统，必须实现多机集群运行。这既提升系统整体稳定性（单机下线时其他节点可接管），又为水平扩展提供可能：通过增加机器来应对负载增长，扩充工作单元以满足更高需求。  
- **响应能力**（**Responsiveness**）——系统必须始终保持合理速度与响应性。即使负载激增或突发错误，请求处理也不应严重延迟。特别需要注意的是，偶发的长时任务绝不能阻塞系统其他部分或显著影响整体性能。  
- **实时更新**（**Live update**）——某些场景下需要在不重启服务的情况下部署新版本软件。例如电话系统进行软件升级时，必须确保已建立的通话不被中断。

若能成功应对这些挑战，系统将成为真正的高可用性系统，无论晴雨皆能为用户提供持续服务。而Erlang正是为解决这些挑战而生——它提供了一系列工具来应对这些难题。通过Erlang并发模型的力量，系统能够获得所有这些特性，最终实现高可用性的终极目标。接下来让我们深入解析Erlang的并发运行机制。

### **1.1.2 Erlang并发模型**（Erlang concurrency）

并发性是Erlang系统的核心与灵魂。几乎所有基于Erlang的复杂生产系统都是高度并发的，以至于这门编程语言有时被称为"面向并发的语言"。如图1.1所示，Erlang没有依赖重量级的操作系统线程或进程，而是将并发控制权掌握在自己手中。

![figure-1-1](/img/elixir-in-action-3-edition/chapter1/figure-1-1.png)

其基本的并发原语称为**Erlang（轻量）进程**（注意区别于操作系统的进程或线程）。典型的Erlang系统会运行成千上万个，甚至数百万个这样的进程。Erlang虚拟机（称为Bogdan/Björn的Erlang抽象机，简称BEAM）使用自身的调度器，在可用的CPU核心间分配进程的执行，从而尽可能地实现并行化。这种进程的实现方式带来了诸多优势：

**容错性**（**FAULT TOLERANCE**）
Erlang进程彼此完全隔离。它们不共享内存，一个进程的崩溃不会导致其他进程崩溃。这有助于将意外错误的影响隔离在局部。即使发生严重问题，其影响范围也仅限于单个进程。此外，Erlang提供了检测进程崩溃并采取补救措施（通常是重启一个新进程来替代崩溃的进程）的机制。

**可扩展性**（**SCALABILITY**）
由于不共享内存，进程之间通过**异步消息**进行通信。这意味着没有复杂的同步机制（如锁、互斥量或信号量）。因此，开发人员可以更简单、更清晰地理解和实现并发实体之间的交互。

典型的Erlang系统被划分为大量并发进程，这些进程相互协作以提供完整的服务。虚拟机能够尽可能高效地将这些进程的执行并行化。因为它们可以利用所有可用的CPU核心，所以Erlang系统具有良好的可扩展性。

**分布式能力**（**DISTRIBUTION**）
无论进程是驻留在同一个BEAM实例中，还是分散在两台独立远程计算机的两个不同实例上，它们之间的通信机制是完全相同的。因此，一个典型的高度并发的、基于Erlang的系统天生就具备跨多台机器分布式部署的能力。这使得系统能够进行**横向扩展**——通过运行一个机器集群来分担总体的系统负载。此外，在多台机器上运行也使系统真正具备了弹性：如果一台机器崩溃，其他机器可以接管其工作。

**响应能力**（**RESPONSIVENESS**）
Erlang运行时环境经过专门调优，以提升系统的整体响应性。如前所述，Erlang通过使用专门的调度器来交替执行大量Erlang进程，从而将多个进程的执行管理权掌握在自己手中。调度器是**抢占式**的——它给予每个进程一个小的执行时间片，然后暂停该进程并运行另一个进程。由于执行时间片很短，单个长时间运行的进程不会阻塞系统的其余部分。此外，I/O操作在内部被委托给单独的线程处理；如果底层操作系统支持，还会利用其内核轮询服务。这意味着任何等待I/O操作完成的进程都不会阻塞其他进程的执行。

甚至垃圾回收机制也经过专门调优，以提升系统响应性。请记住，进程是完全隔离且不共享内存的。这使得**按进程进行垃圾回收**成为可能：无需停止整个系统，每个进程可以根据需要单独进行垃圾回收。这样的回收过程更快速，不会长时间阻塞整个系统。事实上，在多核系统中，完全可能一个CPU核心在进行短暂的垃圾回收，而其他核心仍在正常处理任务。

由此可见，并发性在Erlang中是一个至关重要的元素，其意义远超单纯的并行执行。得益于其底层实现，并发性有力地促进了系统的容错能力、分布式部署和整体响应性。典型的Erlang系统运行着许多并发任务，使用成千上万甚至数百万个进程。这在开发服务端系统时尤其有用，而这些系统往往可以完全用Erlang来实现。

### **1.1.3 服务端系统**（Server-side systems）

Erlang可应用于各种类型的程序和系统，既有基于Erlang的桌面应用实例，也常被用于嵌入式环境。但在我看来，其最擅长的领域在于**服务端系统**——这类系统运行在一台或多台服务器上，必须同时服务众多客户端。这里的"服务端系统"不仅仅是处理请求的简单服务器，它更是一个完整的体系。如图1.2所示，除了处理请求外，它还必须运行各种后台作业，并管理某种服务器范围内的内存状态。

![figure-1-2](/img/elixir-in-action-3-edition/chapter1/figure-1-2.png)

服务端系统通常分布在多台协作产生业务价值的机器上。您可能将不同组件部署在不同机器上，也可能将某些组件部署在多台服务器上以实现负载均衡或支持故障转移场景。

这正是Erlang能极大简化您工作的地方。通过提供使代码具备并发性、可扩展性和分布式能力的原语，它允许您完全使用Erlang来实现整个系统。图1.2中的每个组件都可以实现为一个Erlang进程，这使得系统具备可扩展性、容错性且易于分布式部署。借助Erlang的错误检测和恢复原语，您可以进一步提高系统的可靠性并从意外错误中恢复。

让我们看一个真实案例。我曾专业参与过两个Web服务器的开发，它们都有相似的技术需求：服务大量客户端、处理长时间运行的请求、管理服务器范围内的内存状态、持久化必须在操作系统进程和机器重启后仍能保留的数据，以及运行后台作业。表1.1列出了每个服务器所使用的技术。

**表1.1 两个真实Web服务器所用技术对比**
| 技术需求       | 服务器A                    | 服务器B    |
| :------------- | :------------------------- | :--------- |
| HTTP服务器     | NGINX 和 Phusion Passenger | **Erlang** |
| 请求处理       | Ruby on Rails              | **Erlang** |
| 长时间请求     | Erlang                     | **Erlang** |
| 服务器范围状态 | Erlang                     | **Erlang** |
| 可持久化数据   | Redis                      | **Erlang** |
| 后台作业       | Redis 和 MongoDB           | **Erlang** |
| 服务崩溃恢复   | cron、Bash脚本和Ruby       | **Erlang** |

服务器A由多种技术支持，其中大多数在社区中广为人知。使用这些技术都有特定原因：每一项都是为了解决系统中已有技术的不足而引入的。例如，Ruby on Rails在独立的操作系统进程中处理并发请求。我们需要一种在这些不同进程之间共享数据的方法，因此引入了Redis。同样，MongoDB用于管理持久化的前端数据（主要是用户相关信息）。因此，服务器A中使用的每一项技术背后都有其逻辑，但整个解决方案看起来相当复杂。它不包含在单个项目中；各个组件是分开部署的，并且在开发机器上启动整个系统也非易事。我们甚至不得不开发一个工具来帮助我们在本地启动系统！

相比之下，服务器B在满足相同技术要求的同时，仅依赖单一技术（Erlang），利用该平台专门为此类目的创建并经过大型系统验证的特性。此外，整个服务器是一个单一项目，运行在单个BEAM实例中——在生产环境中，它仅运行在一个操作系统进程内，使用少量操作系统线程。并发性完全由Erlang调度器处理，系统具备可扩展性、响应性和容错性。由于它被实现为一个单一项目，因此系统更容易管理、部署以及在开发机器上本地运行。

需要注意的是，Erlang工具并非总是主流解决方案的完全替代品，例如像NGINX这样的Web服务器、像MongoDB这样的数据库服务器以及像Redis这样的内存键值存储。但Erlang为您提供了选择：它使您能够首先使用纯粹的Erlang来实现初始解决方案，仅在Erlang方案不足时才求助于其他技术。这使得整个系统更加同质化，从而更易于开发和维护。

同样值得注意的是，Erlang并非一座孤岛。它可以运行用C、C++或Rust等语言编写的进程内代码，并且可以与外部组件（如消息队列、内存键值存储和外部数据库）进行通信。因此，选择Erlang并不会剥夺您使用现有第三方技术的权利。相反，您可以根据实际需要选择使用它们，而不是因为您的主要开发平台没有提供解决问题的工具。

现在您已经了解了Erlang的优势及其擅长领域，让我们更深入地看看Erlang究竟是什么。