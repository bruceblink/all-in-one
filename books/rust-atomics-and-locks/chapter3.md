---
sidebar_position: 6
typora-root-url: ./..\..\static
---

# 第 3 章 内存序（Memory Ordering）

在[第2章]()中，我们简要提到了内存序的概念。本章我们将深入探讨这一主题，了解所有可用的内存序选项，最重要的是，明确在何种情况下使用哪一种。

## **重排序与优化**（Reordering and Optimizations）

处理器和编译器为了使程序运行得更快，会施展各种“把戏”。例如，处理器可能会判断程序中两条特定的连续指令彼此不会产生影响，并（如果那样更快的话）乱序执行它们。当一条指令因为要从主内存获取某些数据而暂时阻塞时，只要不会改变程序的行为，后续的几条指令就可能会在这第一条指令完成之前被执行并完成。同样地，编译器如果有理由相信改变顺序或重写程序的某些部分可能导致更快的执行，它也可能会这样做。

但是，重申一遍，**只有在不会改变程序行为的前提下**，它们才会这么做。

让我们看下面这个函数作为例子：

```rust
fn f(a: &mut i32, b: &mut i32) {
    *a += 1;
    *b += 1;
    *a += 1;
}
```

在这里，编译器几乎肯定会理解这些操作的顺序无关紧要，因为在这三个加法操作之间，没有任何操作依赖于 `*a` 或 `*b` 的值。（假设溢出检查已禁用。）因此，它可能会重新排列第二个和第三个操作的顺序，然后将前两个合并为一次加法：

```rust
fn f(a: &mut i32, b: &mut i32) {
    *a += 2;
    *b += 1;
}
```

之后，在执行这个经过优化编译的程序函数时，处理器可能会因为各种原因，最终先执行第二个加法再执行第一个加法，可能是因为 `*b` 在缓存中可用，而 `*a` 必须从主内存中获取。

无论进行何种优化，结果保持不变：`*a` 增加 2，`*b` 增加 1。它们被增加的顺序对你的程序其余部分来说是完全不可见的。

验证特定重排序或其他优化是否会影响程序行为的逻辑**并未将其他线程考虑在内**。在我们上面的例子中，这完全没问题，因为唯一引用（`&mut i32`）保证了不可能有其他东西访问这些值，使得其他线程无关紧要。唯一会出现问题的情况是**当修改线程间共享的数据时**。或者换句话说，**在使用原子操作时**。这就是为什么我们必须明确地告诉编译器和处理器，它们能对我们的原子操作做什么、不能做什么，因为它们通常的逻辑忽略了线程间的交互，可能会允许那些确实会改变程序结果的优化。

有趣的问题是我们如何告知它们。如果我们想精确地说明什么是可以接受的、什么是不可以接受的，并发编程可能会变得极其冗长、容易出错，甚至可能依赖于特定架构：

```rust
let x = a.fetch_add(1,
Dear compiler and processor,
Feel free to reorder this with operations on b,but if there's another thread concurrently executing f,please don't reorder this with operations on c!
Also, processor, don't forget to flush your store buffer!If b is zero, though, it doesn't matter.
In that case, feel free to do whatever is fastest.
Thanks~ <3
);
```

相反，我们只能从一个小的选项集合中进行选择，这些选项由 `std::sync::atomic::Ordering` 枚举表示，每个原子操作都将其作为参数。可用的选项集非常有限，但经过精心挑选，能很好地适应大多数使用场景。这些排序选项非常抽象，并不直接反映所涉及的实际编译器和处理器机制，例如指令重排序。这使得你的并发代码能够做到与架构无关并经得起未来考验。它允许我们在不知道每一个现有及未来处理器和编译器版本细节的情况下进行验证。

Rust 中可用的排序选项有：
*   **宽松排序**：`Ordering::Relaxed`
*   **释放与获取排序**：`Ordering::{Release, Acquire, AcqRel}`
*   **顺序一致排序**：`Ordering::SeqCst`

在 C++ 中，还有一种称为**消费排序**的东西，它被有意地从 Rust 中省略了，但讨论一下也很有趣。