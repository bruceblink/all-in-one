---
sidebar_position: 6
typora-root-url: ./..\..\static
---

# 第 3 章 内存序（Memory Ordering）

在[第2章]()中，我们简要提到了内存序的概念。本章我们将深入探讨这一主题，了解所有可用的内存序选项，最重要的是，明确在何种情况下使用哪一种。

## **重排序与优化**（Reordering and Optimizations）

处理器和编译器为了使程序运行得更快，会施展各种“把戏”。例如，处理器可能会判断程序中两条特定的连续指令彼此不会产生影响，并（如果那样更快的话）乱序执行它们。当一条指令因为要从主内存获取某些数据而暂时阻塞时，只要不会改变程序的行为，后续的几条指令就可能会在这第一条指令完成之前被执行并完成。同样地，编译器如果有理由相信改变顺序或重写程序的某些部分可能导致更快的执行，它也可能会这样做。

但是，重申一遍，**只有在不会改变程序行为的前提下**，它们才会这么做。

让我们看下面这个函数作为例子：

```rust
fn f(a: &mut i32, b: &mut i32) {
    *a += 1;
    *b += 1;
    *a += 1;
}
```

在这里，编译器几乎肯定会理解这些操作的顺序无关紧要，因为在这三个加法操作之间，没有任何操作依赖于 `*a` 或 `*b` 的值。（假设溢出检查已禁用。）因此，它可能会重新排列第二个和第三个操作的顺序，然后将前两个合并为一次加法：

```rust
fn f(a: &mut i32, b: &mut i32) {
    *a += 2;
    *b += 1;
}
```

之后，在执行这个经过优化编译的程序函数时，处理器可能会因为各种原因，最终先执行第二个加法再执行第一个加法，可能是因为 `*b` 在缓存中可用，而 `*a` 必须从主内存中获取。

无论进行何种优化，结果保持不变：`*a` 增加 2，`*b` 增加 1。它们被增加的顺序对你的程序其余部分来说是完全不可见的。

验证特定重排序或其他优化是否会影响程序行为的逻辑**并未将其他线程考虑在内**。在我们上面的例子中，这完全没问题，因为唯一引用（`&mut i32`）保证了不可能有其他东西访问这些值，使得其他线程无关紧要。唯一会出现问题的情况是**当修改线程间共享的数据时**。或者换句话说，**在使用原子操作时**。这就是为什么我们必须明确地告诉编译器和处理器，它们能对我们的原子操作做什么、不能做什么，因为它们通常的逻辑忽略了线程间的交互，可能会允许那些确实会改变程序结果的优化。

有趣的问题是我们如何告知它们。如果我们想精确地说明什么是可以接受的、什么是不可以接受的，并发编程可能会变得极其冗长、容易出错，甚至可能依赖于特定架构：

```rust
let x = a.fetch_add(1,
Dear compiler and processor,
Feel free to reorder this with operations on b,but if there's another thread concurrently executing f,please don't reorder this with operations on c!
Also, processor, don't forget to flush your store buffer!If b is zero, though, it doesn't matter.
In that case, feel free to do whatever is fastest.
Thanks~ <3
);
```

相反，我们只能从一个小的选项集合中进行选择，这些选项由 `std::sync::atomic::Ordering` 枚举表示，每个原子操作都将其作为参数。可用的选项集非常有限，但经过精心挑选，能很好地适应大多数使用场景。这些排序选项非常抽象，并不直接反映所涉及的实际编译器和处理器机制，例如指令重排序。这使得你的并发代码能够做到与架构无关并经得起未来考验。它允许我们在不知道每一个现有及未来处理器和编译器版本细节的情况下进行验证。

Rust 中可用的排序选项有：
*   **宽松排序**：`Ordering::Relaxed`
*   **释放与获取排序**：`Ordering::{Release, Acquire, AcqRel}`
*   **顺序一致排序**：`Ordering::SeqCst`

在 C++ 中，还有一种称为**消费排序**的东西，它被有意地从 Rust 中省略了，但讨论一下也很有趣。

## **内存模型**（The Memory Model）

不同的内存排序选项有着严格的形式化定义，以确保我们确切地知道可以做出哪些假设，也让编译器开发者确切地知道他们需要为我们提供哪些保证。为了将其与特定处理器架构的细节解耦，内存排序是根据一个抽象的内存模型来定义的。

Rust 的内存模型（大部分借鉴自 C++）并不与任何现有的处理器架构完全匹配，而是一个抽象的模型，具有一组严格的规则。这些规则试图代表所有当前和未来架构的最大公约数，同时也给予编译器在分析和优化程序时足够的自由度，以做出有用的假设。

我们已经在第11页的“借用与数据竞争”一节中看到了内存模型的实际应用，在那里我们讨论了数据竞争如何导致未定义行为。Rust 的内存模型允许并发的原子存储，但将同一变量的并发非原子存储视为数据竞争，从而导致未定义行为。

然而，在大多数处理器架构上，原子存储和常规的非原子存储实际上并没有区别，这一点我们将在第7章中看到。可以说内存模型比实际需要的更严格，但这些严格的规则使得程序更易于推理，无论是对编译器还是对程序员而言都是如此，并且为未来的发展留下了空间。

## **Happens-Before关系**（Happens-Before Relationship）

内存模型根据**Happens-Before Relationship**来定义操作发生的顺序。这意味着，作为一个抽象模型，它不谈论机器指令、缓存、缓冲区、时序、指令重排序、编译器优化等等，而是只定义了一种情况：保证一件事在另一件事之前发生，而其他所有事情的顺序则不予定义。

基本的**Happens-Before**规则是：在同一线程内发生的一切都是按顺序发生的。如果一个线程执行 `f(); g();`，那么 `f()` 发生在 `g()` 之前。

然而，在线程之间，发生前关系只出现在几种特定情况中，例如创建和连接线程、解锁和锁定互斥锁，以及通过使用非宽松内存排序的原子操作。宽松内存排序是最基本（且性能最高）的内存排序，它本身永远不会导致任何跨线程的**Happens-Before**关系。

为了探究这意味着什么，让我们看看下面的例子，我们假设 `a` 和 `b` 由不同的线程并发执行：

```rust
static X: AtomicI32 = AtomicI32::new(0);
static Y: AtomicI32 = AtomicI32::new(0);

fn a() {
    X.store(10, Relaxed);
    Y.store(20, Relaxed);
}

fn b() {
    let y = Y.load(Relaxed);
    let x = X.load(Relaxed);
    println!("{x} {y}");
}
```

如上所述，基本的**Happens-Before**规则是：在同一线程内发生的一切都是按顺序发生的。在这个例子中：`X.store(10, Relaxed)` 发生在 `Y.store(20, Relaxed)` 之前，而 `Y.load(Relaxed)` 发生在 `X.load(Relaxed)` 之前，如图 3-1 所示。由于我们使用宽松内存排序，在我们的示例中没有其他的**Happens-Before**关系。

![figure-3-1](/img/rust-atomics-and-locks/chapter3/figure-3-1.png)

**图 3-1. 示例代码中原子操作之间的发生前关系**

如果 `a` 或 `b` 中的任何一个在另一个开始之前完成，那么输出将是 `0 0` 或 `10 20`。如果 `a` 和 `b` 并发运行，很容易看出输出可能是 `10 0`。发生这种情况的一种可能操作顺序如下：（此处省略具体顺序描述，但意指可能的交错执行导致此结果）。

### **创建与连接线程**（Spawning and Joining）

创建一个线程会在 `spawn()` 调用之前发生的事情和新线程之间建立**Happens-Before**关系。类似地，连接一个线程会在被连接的线程和 `join()` 调用之后发生的事情之间建立**Happens-Before**关系。

为了演示，以下示例中的断言不可能失败：

```rust
static X: AtomicI32 = AtomicI32::new(0);

fn main() {
    X.store(1, Relaxed);
    let t = thread::spawn(f);
    X.store(2, Relaxed);
    t.join().unwrap();
    X.store(3, Relaxed);
}

fn f() {
    let x = X.load(Relaxed);
    assert!(x == 1 || x == 2);
}
```

由于由连接和创建操作形成的**Happens-Before**关系，我们可以确定，对 `X` 的加载发生在第一次存储之后，但在最后一次存储之前，如图 3-2 所示。然而，它观察到的是第二次存储之前还是之后的值是不可预测的。换句话说，它可能加载到 1 或 2，但不会是 0 或 3。

![figure-3-2](/img/rust-atomics-and-locks/chapter3/figure-3-2.png)

**图 3-2. 示例代码中创建、连接、存储和加载操作之间的Happens-Before关系**

## **宽松排序**（Relaxed Ordering）

虽然使用宽松内存排序的原子操作不提供任何**发生前**关系，但它们确实保证了每个独立原子变量的**总修改顺序**。这意味着，从每一个线程的视角来看，对同一原子变量的所有修改都以相同的顺序发生。

为了说明这意味着什么，请考虑以下示例，我们假设 `a` 和 `b` 由不同的线程并发执行：

```rust
static X: AtomicI32 = AtomicI32::new(0);

fn a() {
    X.fetch_add(5, Relaxed);
    X.fetch_add(10, Relaxed);
}

fn b() {
    let a = X.load(Relaxed);
    let b = X.load(Relaxed);
    let c = X.load(Relaxed);
    let d = X.load(Relaxed);
    println!("{a} {b} {c} {d}");
}
```

在这个例子中，只有一个线程修改 `X`，这使得很容易看出 `X` 的修改顺序只有一种可能：0→5→15。它从零开始，然后变成五，最后被改为十五。线程不能观察到任何与这个总修改顺序不一致的 `X` 值。这意味着 `0 0 0 0`、`0 0 5 15` 和 `0 15 15 15` 是另一个线程中打印语句可能的一些结果，而 `0 5 0 15` 或 `0 0 10 15` 这样的输出是不可能的。

即使对于一个原子变量存在多个可能的修改顺序，所有线程也会就一个顺序达成一致。

让我们用两个独立的函数 `a1` 和 `a2` 替换 `a`，我们假设每个函数都由一个独立的线程执行：

```rust
fn a1() {
    X.fetch_add(5, Relaxed);
}

fn a2() {
    X.fetch_add(10, Relaxed);
}
```

假设这些是仅有的修改 `X` 的线程，那么现在有两种可能的修改顺序：要么是 0→5→15，要么是 0→10→15，这取决于哪个 `fetch_add` 操作先执行。无论发生哪种情况，所有线程都观察到相同的顺序。所以，即使我们有成百上千个额外线程都在运行我们的 `b()` 函数，我们知道如果其中一个打印出 10，那么顺序必须是 0→10→15，并且它们中没有一个可能打印出 5。反之亦然。

在第二章中，我们看到了几个用例示例，其中对单个变量的这种总修改顺序保证就足够了，使得宽松内存排序可以满足需求。然而，如果我们尝试超越这些例子进行更复杂的操作，很快就会看到我们需要比宽松内存排序更强的保证。

> **凭空出现的值**
>
> 当操作以循环方式相互依赖时，宽松内存排序缺乏顺序保证可能会导致一些理论上的复杂情况。
>
> 为了演示，这里有一个刻意设计的例子，两个线程从一个原子变量加载值并将其存储到另一个原子变量中：
>
>```rust
>static X: AtomicI32 = AtomicI32::new(0);
>static Y: AtomicI32 = AtomicI32::new(0);
>
>fn main() {
>    let a = thread::spawn(|| {
>        let x = X.load(Relaxed);
>        Y.store(x, Relaxed);
>    });
>    let b = thread::spawn(|| {
>        let y = Y.load(Relaxed);
>        X.store(y, Relaxed);
>    });
>    a.join().unwrap();
>    b.join().unwrap();
>    assert_eq!(X.load(Relaxed), 0); // 可能会失败？
>    assert_eq!(Y.load(Relaxed), 0); // 可能会失败？
>}
>```
>
>似乎很容易得出结论：`X` 和 `Y` 的值除了零之外永远不会是别的值，因为存储操作只存储从这些相同的原子变量加载的值，而这些值始终是零。
>
>然而，如果我们严格遵循理论上的内存模型，就不得不承认我们的循环推理，并得出一个可怕的结论：我们可能错了。事实上，从技术上讲，内存模型允许这样一种结果：最终 `X` 和 `Y` 都是 37，或者任何其他值，从而导致断言失败。
>
>由于缺乏顺序保证，这两个线程的加载操作可能都会看到另一个线程存储操作的结果，从而允许操作顺序中出现循环：我们将 37 存储到 `Y`，是因为我们从 `X` 加载了 37，而之所以将 37 存储到 `X`，是因为我们从 `Y` 加载了 37，而这个值正是我们存储到 `Y` 的。
>
>幸运的是，这种**凭空出现的值**的可能性被普遍认为是理论模型中的一个缺陷，而不是你在实践中需要考虑的问题。如何在不允许此类异常的情况下形式化宽松内存排序，这个理论问题尚未解决。虽然这对于形式化验证来说是个棘手的问题，让许多理论家夜不能寐，但我们其他人则可以幸福地无视这个问题，因为知道这在实践中不会发生。