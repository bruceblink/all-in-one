---
sidebar_position: 6
typora-root-url: ./..\..\static
---

# 第 3 章 内存序（Memory Ordering）

在[第2章]()中，我们简要提到了内存序的概念。本章我们将深入探讨这一主题，了解所有可用的内存序选项，最重要的是，明确在何种情况下使用哪一种。

## **重排序与优化**（Reordering and Optimizations）

处理器和编译器为了使程序运行得更快，会施展各种“把戏”。例如，处理器可能会判断程序中两条特定的连续指令彼此不会产生影响，并（如果那样更快的话）乱序执行它们。当一条指令因为要从主内存获取某些数据而暂时阻塞时，只要不会改变程序的行为，后续的几条指令就可能会在这第一条指令完成之前被执行并完成。同样地，编译器如果有理由相信改变顺序或重写程序的某些部分可能导致更快的执行，它也可能会这样做。

但是，重申一遍，**只有在不会改变程序行为的前提下**，它们才会这么做。

让我们看下面这个函数作为例子：

```rust
fn f(a: &mut i32, b: &mut i32) {
    *a += 1;
    *b += 1;
    *a += 1;
}
```

在这里，编译器几乎肯定会理解这些操作的顺序无关紧要，因为在这三个加法操作之间，没有任何操作依赖于 `*a` 或 `*b` 的值。（假设溢出检查已禁用。）因此，它可能会重新排列第二个和第三个操作的顺序，然后将前两个合并为一次加法：

```rust
fn f(a: &mut i32, b: &mut i32) {
    *a += 2;
    *b += 1;
}
```

之后，在执行这个经过优化编译的程序函数时，处理器可能会因为各种原因，最终先执行第二个加法再执行第一个加法，可能是因为 `*b` 在缓存中可用，而 `*a` 必须从主内存中获取。

无论进行何种优化，结果保持不变：`*a` 增加 2，`*b` 增加 1。它们被增加的顺序对你的程序其余部分来说是完全不可见的。

验证特定重排序或其他优化是否会影响程序行为的逻辑**并未将其他线程考虑在内**。在我们上面的例子中，这完全没问题，因为唯一引用（`&mut i32`）保证了不可能有其他东西访问这些值，使得其他线程无关紧要。唯一会出现问题的情况是**当修改线程间共享的数据时**。或者换句话说，**在使用原子操作时**。这就是为什么我们必须明确地告诉编译器和处理器，它们能对我们的原子操作做什么、不能做什么，因为它们通常的逻辑忽略了线程间的交互，可能会允许那些确实会改变程序结果的优化。

有趣的问题是我们如何告知它们。如果我们想精确地说明什么是可以接受的、什么是不可以接受的，并发编程可能会变得极其冗长、容易出错，甚至可能依赖于特定架构：

```rust
let x = a.fetch_add(1,
Dear compiler and processor,
Feel free to reorder this with operations on b,but if there's another thread concurrently executing f,please don't reorder this with operations on c!
Also, processor, don't forget to flush your store buffer!If b is zero, though, it doesn't matter.
In that case, feel free to do whatever is fastest.
Thanks~ <3
);
```

相反，我们只能从一个小的选项集合中进行选择，这些选项由 `std::sync::atomic::Ordering` 枚举表示，每个原子操作都将其作为参数。可用的选项集非常有限，但经过精心挑选，能很好地适应大多数使用场景。这些排序选项非常抽象，并不直接反映所涉及的实际编译器和处理器机制，例如指令重排序。这使得你的并发代码能够做到与架构无关并经得起未来考验。它允许我们在不知道每一个现有及未来处理器和编译器版本细节的情况下进行验证。

Rust 中可用的排序选项有：
*   **宽松排序**：`Ordering::Relaxed`
*   **释放与获取排序**：`Ordering::{Release, Acquire, AcqRel}`
*   **顺序一致排序**：`Ordering::SeqCst`

在 C++ 中，还有一种称为**消费排序**的东西，它被有意地从 Rust 中省略了，但讨论一下也很有趣。

## **内存模型**（The Memory Model）

不同的内存排序选项有着严格的形式化定义，以确保我们确切地知道可以做出哪些假设，也让编译器开发者确切地知道他们需要为我们提供哪些保证。为了将其与特定处理器架构的细节解耦，内存排序是根据一个抽象的内存模型来定义的。

Rust 的内存模型（大部分借鉴自 C++）并不与任何现有的处理器架构完全匹配，而是一个抽象的模型，具有一组严格的规则。这些规则试图代表所有当前和未来架构的最大公约数，同时也给予编译器在分析和优化程序时足够的自由度，以做出有用的假设。

我们已经在第11页的“借用与数据竞争”一节中看到了内存模型的实际应用，在那里我们讨论了数据竞争如何导致未定义行为。Rust 的内存模型允许并发的原子存储，但将同一变量的并发非原子存储视为数据竞争，从而导致未定义行为。

然而，在大多数处理器架构上，原子存储和常规的非原子存储实际上并没有区别，这一点我们将在第7章中看到。可以说内存模型比实际需要的更严格，但这些严格的规则使得程序更易于推理，无论是对编译器还是对程序员而言都是如此，并且为未来的发展留下了空间。

## **Happens-Before关系**（Happens-Before Relationship）

内存模型根据**Happens-Before Relationship**来定义操作发生的顺序。这意味着，作为一个抽象模型，它不谈论机器指令、缓存、缓冲区、时序、指令重排序、编译器优化等等，而是只定义了一种情况：保证一件事在另一件事之前发生，而其他所有事情的顺序则不予定义。

基本的**Happens-Before**规则是：在同一线程内发生的一切都是按顺序发生的。如果一个线程执行 `f(); g();`，那么 `f()` 发生在 `g()` 之前。

然而，在线程之间，发生前关系只出现在几种特定情况中，例如创建和连接线程、解锁和锁定互斥锁，以及通过使用非宽松内存排序的原子操作。宽松内存排序是最基本（且性能最高）的内存排序，它本身永远不会导致任何跨线程的**Happens-Before**关系。

为了探究这意味着什么，让我们看看下面的例子，我们假设 `a` 和 `b` 由不同的线程并发执行：

```rust
static X: AtomicI32 = AtomicI32::new(0);
static Y: AtomicI32 = AtomicI32::new(0);

fn a() {
    X.store(10, Relaxed);
    Y.store(20, Relaxed);
}

fn b() {
    let y = Y.load(Relaxed);
    let x = X.load(Relaxed);
    println!("{x} {y}");
}
```

如上所述，基本的**Happens-Before**规则是：在同一线程内发生的一切都是按顺序发生的。在这个例子中：`X.store(10, Relaxed)` 发生在 `Y.store(20, Relaxed)` 之前，而 `Y.load(Relaxed)` 发生在 `X.load(Relaxed)` 之前，如图 3-1 所示。由于我们使用宽松内存排序，在我们的示例中没有其他的**Happens-Before**关系。

![figure-3-1](/img/rust-atomics-and-locks/chapter3/figure-3-1.png)

**图 3-1. 示例代码中原子操作之间的发生前关系**

如果 `a` 或 `b` 中的任何一个在另一个开始之前完成，那么输出将是 `0 0` 或 `10 20`。如果 `a` 和 `b` 并发运行，很容易看出输出可能是 `10 0`。发生这种情况的一种可能操作顺序如下：（此处省略具体顺序描述，但意指可能的交错执行导致此结果）。

### **创建与连接线程**（Spawning and Joining）

创建一个线程会在 `spawn()` 调用之前发生的事情和新线程之间建立**Happens-Before**关系。类似地，连接一个线程会在被连接的线程和 `join()` 调用之后发生的事情之间建立**Happens-Before**关系。

为了演示，以下示例中的断言不可能失败：

```rust
static X: AtomicI32 = AtomicI32::new(0);

fn main() {
    X.store(1, Relaxed);
    let t = thread::spawn(f);
    X.store(2, Relaxed);
    t.join().unwrap();
    X.store(3, Relaxed);
}

fn f() {
    let x = X.load(Relaxed);
    assert!(x == 1 || x == 2);
}
```

由于由连接和创建操作形成的**Happens-Before**关系，我们可以确定，对 `X` 的加载发生在第一次存储之后，但在最后一次存储之前，如图 3-2 所示。然而，它观察到的是第二次存储之前还是之后的值是不可预测的。换句话说，它可能加载到 1 或 2，但不会是 0 或 3。

![figure-3-2](/img/rust-atomics-and-locks/chapter3/figure-3-2.png)

**图 3-2. 示例代码中创建、连接、存储和加载操作之间的Happens-Before关系**