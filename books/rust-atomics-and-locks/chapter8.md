---
sidebar_position: 7
typora-root-url: ./..\..\static
---

# 第 8 章 操作系统原语（Operating System Primitives）

到目前为止，我们主要关注的是非阻塞操作。如果我们想要实现像互斥锁或条件变量这样的东西，即能够等待另一个线程解锁或通知它，我们需要一种有效阻塞当前线程的方法。

正如我们在[第4章]()中看到的，我们可以通过自旋（反复尝试某件事）在没有操作系统帮助的情况下自己实现这一点，但这很容易浪费大量处理器时间。然而，如果我们想要高效地阻塞，就需要操作系统内核的帮助。

内核，或者更具体地说是其中的调度器部分，负责决定哪个进程或线程在何时、运行多长时间以及在哪个处理器核心上运行。当一个线程等待某件事情发生时，内核可以停止给它任何处理器时间，优先考虑那些能更好利用这种稀缺资源的其他线程。

我们需要一种方法来通知内核我们正在等待某事，并要求它将我们的线程置于休眠状态，直到相关的事情发生。

## **与内核交互**（Interfacing with the Kernel）

与内核通信的方式在很大程度上取决于操作系统，甚至通常取决于其版本。通常，其工作方式的细节隐藏在一个或多个为我们处理此事的库背后。例如，使用Rust标准库，我们可以直接调用 `File::open()` 来打开文件，而无需了解操作系统内核接口的任何细节。类似地，使用C标准库 `libc`，可以调用标准的 `fopen()` 函数来打开文件。调用这样的函数最终会导致对操作系统内核的调用，也称为系统调用（syscall），这通常通过专门的处理器指令完成。（在某些架构上，该指令字面意思就是 `syscall`。）

程序通常被期望（有时甚至被要求）不直接进行任何系统调用，而是使用操作系统附带的高级库。在Unix系统（例如基于Linux的系统）上，`libc` 承担了提供内核标准接口的特殊角色。

“可移植操作系统接口”标准，通常称为POSIX标准，对Unix系统上的 `libc` 提出了额外要求。例如，除了C标准中的 `fopen()` 函数外，POSIX还要求存在用于打开文件的较低级别函数 `open()` 和 `openat()`，这些函数通常直接对应于系统调用。由于 `libc` 在Unix系统上的特殊地位，用C以外语言编写的程序通常仍使用 `libc` 进行所有与内核的交互。

Rust软件，包括标准库，通常通过同名的 `libc` crate 来使用 `libc`。

具体对于Linux，系统调用接口被保证是稳定的，允许我们直接进行系统调用，而无需使用 `libc`。虽然这不是最常见或最被建议的途径，但它正慢慢变得更受欢迎。

然而，在macOS（同样遵循POSIX标准的Unix操作系统）上，内核的系统调用接口并不稳定，我们不应该直接使用它。程序允许使用的唯一稳定接口是通过系统附带的库提供的，例如 `libc`、`libc++` 以及用于C、C++、Objective-C和Swift（Apple选择的编程语言）的各种其他库。

Windows不遵循POSIX标准。它没有附带作为内核主要接口的扩展 `libc`，而是附带一组单独的库，例如 `kernel32.dll`，这些库提供Windows特定的函数，例如用于打开文件的 `CreateFileW`。就像在macOS上一样，我们不应该使用未记录的较低级别函数或直接进行系统调用。

通过它们的库，操作系统为我们提供了需要与内核交互的同步原语，例如互斥锁和条件变量。它们的实现中哪部分属于此类库或属于内核，因操作系统而异。例如，有时互斥锁的锁定和解锁操作直接对应于内核系统调用，而在其他系统上，库处理大部分操作，并且只有在需要阻塞或唤醒线程时才会执行系统调用。（后者往往更高效，因为进行系统调用可能很慢。）

