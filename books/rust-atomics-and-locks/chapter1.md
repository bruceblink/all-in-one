---
sidebar_position: 4
typora-root-url: ./..\..\static
---

# 第 1 章 Rust 并发基础

早在多核处理器尚未普及之前，操作系统就已经允许一台计算机同时运行多个程序。这是通过在进程之间快速切换来实现的，使每个进程依次获得一点点执行进度。如今，几乎所有的计算机，甚至手机和手表，都配备了多核处理器，能够真正地并行执行多个进程。

操作系统会尽可能地将各个进程彼此隔离，使得一个程序在运行时可以专注于自己的工作，而完全无需知道其他进程在做什么。例如，一个进程通常不能直接访问另一个进程的内存，也不能以任何方式与其通信，除非先请求操作系统内核的帮助。

不过，一个程序可以在同一进程内创建***额外的执行线程***。处于同一进程中的线程并不会彼此隔离，它们共享内存，并且可以通过这块共享内存相互交互。

本章将介绍如何在 Rust 中创建线程，以及与线程相关的所有基础概念，例如如何在多个线程之间安全地共享数据。本章中解释的概念是全书其余内容的基础。

> 如果你已经熟悉 Rust 的这些部分，可以直接跳到后面的章节。不过，在继续阅读下一章之前，请务必确保你已经很好地理解了以下内容：线程、内部可变性（interior mutability）、`Send` 和 `Sync`，以及什么是互斥锁（mutex）、条件变量（condition variable）和线程停泊（thread parking）。



## **Rust 中的线程** （Threads in Rust）

每个程序都恰好从一个线程开始：主线程（main thread）。这个线程会执行你的 `main` 函数，并且在需要时可以用来创建更多的线程。

在 Rust 中，新线程是通过标准库里的 `std::thread::spawn` 函数创建的。它只接受一个参数：新线程要执行的函数。当这个函数返回时，线程也就随之结束。

我们来看一个示例：

```rust
use std::thread;

fn main() {
    thread::spawn(f);
    thread::spawn(f);
    println!("Hello from the main thread.");
}

fn f() {
    println!("Hello from another thread!");
    let id = thread::current().id();
    println!("This is my thread id: {id:?}");
}
```

这里我们创建了两个线程，它们都会以 `f` 作为各自的主函数来执行。这两个线程都会打印一条消息并显示它们的线程 ID，而主线程也会打印一条自己的消息。


>  **线程 ID**
>
> Rust 标准库会为每个线程分配一个唯一的标识符。这个标识符可以通过 `Thread::id()` 获取，其类型是 `ThreadId`。你几乎不能对 `ThreadId` 做太多事情，除了复制它以及进行相等性比较。标准库并不保证这些 ID 是连续分配的，只保证每个线程的 ID 都彼此不同。

如果你多运行几次上面的示例程序，可能会注意到输出在不同运行之间会有所差异。下面是我在某一次运行时，在自己机器上得到的输出结果：

```
Hello from the main thread.
Hello from another thread!
This is my thread id:
```

令人意外的是，输出内容似乎缺失了一部分。

刚才发生的情况是：主线程在新创建的线程还没有执行完各自的函数之前，就已经执行完了 `main` 函数。
一旦从 `main` 返回，整个程序就会退出，即使此时仍然有其他线程在运行。

在这个具体的示例中，其中一个新创建的线程只来得及把第二条消息打印到一半，程序就被主线程终止了。

如果我们希望在从 `main` 返回之前确保所有线程都已经执行完成，就需要等待它们结束，也就是对它们进行 *join*。为此，我们必须使用 `spawn` 函数返回的 `JoinHandle`：

```rust
fn main() {
    let t1 = thread::spawn(f);
    let t2 = thread::spawn(f);
    println!("Hello from the main thread.");
    t1.join().unwrap();
    t2.join().unwrap();
}
```

`.join()` 方法会一直等待，直到对应的线程执行完毕，并返回一个 `std::thread::Result`。
如果线程因为发生 panic 而没有成功完成函数执行，这个结果中就会包含 panic 的信息。我们可以尝试对这种情况进行处理，或者像这里一样直接调用 `.unwrap()`，在尝试 join 一个发生 panic 的线程时让当前线程也 panic。

运行这个版本的程序后，就不会再出现输出被截断的情况了：

```
Hello from the main thread.
Hello from another thread!
This is my thread id: ThreadId(3)
Hello from another thread!
This is my thread id: ThreadId(2)
```

唯一仍然会在多次运行之间发生变化的，是这些消息被打印出来的顺序，例如：

```
Hello from the main thread.
Hello from another thread!
Hello from another thread!
This is my thread id: ThreadId(2)
This is my thread id: ThreadId(3)
```

> **输出锁定**
>
> `println!` 宏会使用 `std::io::Stdout::lock()` 来确保输出过程不会被打断。在真正写入任何内容之前，一个 `println!()` 表达式会等待所有正在并发执行的 `println!()` 完成。
> 如果不是这样，我们就可能看到更加交错、难以阅读的输出，例如：
>
> Hello fromHello from another thread!
>
> another This is my threthreadHello fromthread id: ThreadId!
>
> ( the main thread.
>
> 2)This is my thread 
>
> id: ThreadId(3)

相比前面示例中直接把函数名传给 `std::thread::spawn`，更常见的做法是向它传入一个闭包。这样我们就可以捕获一些值，并将它们移动到新线程中：

```rust
let numbers = vec![1, 2, 3];
thread::spawn(move || {
    for n in numbers {
        println!("{n}");
    }
}).join().unwrap();
```

在这里，由于使用了 `move` 闭包，`numbers` 的所有权被转移给了新创建的线程。如果没有使用 `move` 关键字，闭包就会通过引用来捕获 `numbers`。这会导致编译错误，因为新线程的生命周期可能会长于该变量本身。

由于一个线程可能会一直运行到程序执行的最后，`spawn` 函数对其参数类型施加了 `'static` 生命周期约束。换句话说，它只接受那些可以被长期保存的函数或闭包。而一个通过引用捕获局部变量的闭包，就无法满足这一要求——一旦该局部变量离开作用域，这个引用立刻就会失效。

要从线程中取回一个值，可以通过在闭包中返回该值来实现。这个返回值可以从 `join` 方法返回的 `Result` 中获取：

```rust
let numbers = Vec::from_iter(0..=1000);
let t = thread::spawn(move || {
    let len = numbers.len();
    let sum = numbers.into_iter().sum::<usize>();
    sum / len
});
let average = t.join().unwrap();
println!("average: {average}");
```

在这里，线程闭包返回的值会通过 `join` 方法传回主线程。
如果 `numbers` 为空，那么线程在尝试做除零运算时就会发生 panic，而 `join` 会返回这个 panic 信息；由于我们对其调用了 `unwrap()`，主线程也会因此发生 panic。


> **线程构建器（Thread Builder）**
>
> `std::thread::spawn` 函数实际上只是`std::thread::Builder::new().spawn().unwrap()`
> 这一写法的一个便捷封装。
>
> `std::thread::Builder` 允许你在创建线程之前对其进行一些配置。你可以用它来设置新线程的栈大小，也可以为新线程指定一个名字。
> 线程的名字可以通过 `std::thread::current().name()` 获取，它会出现在 panic 信息中，并且在大多数平台上的监控和调试工具里都是可见的。
>
> 此外，`Builder` 的 `spawn` 方法会返回一个 `std::io::Result`，从而允许你显式地处理线程创建失败的情况。这种失败可能发生在操作系统内存不足，或者你的程序被施加了资源限制时。
> 相比之下，`std::thread::spawn` 在无法创建新线程时会直接 panic。



## **作用域线程（Scoped Threads）**

如果我们能够确定，一个被创建的线程**一定不会**比某个作用域活得更久，那么这个线程就可以安全地借用一些并非“永久存在”的东西，比如局部变量——只要这些被借用的值至少能活到该作用域结束为止。

Rust 标准库提供了 `std::thread::scope` 函数，用来创建这种**受作用域限制的线程**。它允许我们创建一些线程，并保证这些线程绝不会活过传入该函数的闭包作用域，从而使安全地借用局部变量成为可能。

它的工作方式通过一个示例最容易理解：

```rust
let numbers = vec![1, 2, 3];

thread::scope(|s| { //(1)
    s.spawn(|| { //(2)
        println!("length: {}", numbers.len());
    });
    s.spawn(|| { //(2)
        for n in &numbers {
            println!("{n}");
        }
    });
}); //(3)
```

> (1) 我们调用 `std::thread::scope`，并向它传入一个闭包。这个闭包会被立即执行，并且接收一个参数 `s`，表示当前的作用域。

> (2) 我们使用 `s` 来创建线程。这里传入的闭包可以直接借用像 `numbers` 这样的局部变量。

> (3) 当作用域结束时，所有尚未被 `join` 的线程都会被自动 `join`。

这种模式保证了：在该作用域内创建的所有线程，都不可能比这个作用域活得更久。正因为如此，这种作用域内的 `spawn` 方法**不要求**其参数类型满足 `'static` 约束，从而允许我们引用任何生命周期至少覆盖该作用域的值，例如这里的 `numbers`。

在上面的示例中，两个新线程都在并发地访问 `numbers`。这完全没有问题，因为它们（以及主线程）都没有对其进行修改。但如果我们把第一个线程改成去修改 `numbers`，如下所示，编译器就不会再允许我们创建另一个同样使用 `numbers` 的线程：

```rust
let mut numbers = vec![1, 2, 3];

thread::scope(|s| {
    s.spawn(|| {
        numbers.push(1);
    });
    s.spawn(|| {
        numbers.push(2); // 错误！
    });
});
```

具体的错误信息会随着 Rust 编译器版本的不同而有所变化（因为编译器一直在改进诊断信息），但尝试编译上述代码时，通常会得到类似下面的错误：

```
error[E0499]: cannot borrow `numbers` as mutable more than once at a time
 --> example.rs:7:13
  |
4 |     s.spawn(|| {
  |              -- 第一次可变借用发生在这里
5 |         numbers.push(1);
  |         ------- 第一次借用是由于在闭包中使用了 `numbers`
  |
7 |     s.spawn(|| {
  |              ^^ 第二次可变借用发生在这里
8 |         numbers.push(2);
  |         ------- 第二次借用是由于在闭包中使用了 `numbers`
```


> **Leakpocalypse（“泄漏末日”）**
>
> 在 Rust 1.0 之前，标准库中曾经有一个名为 `std::thread::scoped` 的函数，它的行为和 `std::thread::spawn` 类似，都会直接创建一个线程。
> 不同之处在于，它允许捕获非 `'static` 的值，因为它返回的不是 `JoinHandle`，而是一个 `JoinGuard`：当这个 `JoinGuard` 被丢弃（drop）时，线程就会被自动 `join`。因此，任何被借用的数据只需要活到这个 `JoinGuard` 被丢弃为止即可。只要 `JoinGuard` 最终一定会被丢弃，这看起来似乎是安全的。
>
> 然而，在 Rust 1.0 发布前不久，人们逐渐意识到：**根本无法保证某个值一定会被丢弃**。
> 存在很多方式——例如构造一个由引用计数节点组成的环——可以让某个值被“遗忘”或泄漏，而不会触发它的 `drop`。
>
> 最终，在后来被一些人称为 **“Leakpocalypse”** 的事件中，大家得出了一个结论：一个（安全的）接口设计，**不能依赖“对象最终一定会被 drop”这一假设**。
> 泄漏一个对象，合理的后果可以是连带泄漏更多对象（例如泄漏一个 `Vec` 也会泄漏其中的元素），但绝不能导致未定义行为（undefined behavior）。
>
> 基于这一结论，`std::thread::scoped` 被认为是不安全的，并最终从标准库中移除。同时，`std::mem::forget` 也从一个 `unsafe` 函数升级为安全函数，用以强调这样一个事实：**遗忘（或泄漏）某个值始终是可能发生的事情**。
>
> 直到很久之后，在 Rust 1.63 中，一个采用全新设计的 `std::thread::scoped`（也就是如今的 `std::thread::scope`）才被重新引入标准库，而这一次的设计不再依赖 `Drop` 来保证正确性。



## **共享所有权与引用计数（Shared Ownership and Reference Counting）**

到目前为止，我们已经看过两种在线程间处理数据的方式：

1. 使用 `move` 闭包将值的所有权转移给线程（参见“Rust 中的线程”一节）；
2. 从生命周期更长的父线程借用数据（参见“作用域线程”一节）。

但是，如果要在两个线程之间共享数据，而**无法保证其中任何一个线程会比另一个线程活得更久**，那么它们都不能成为数据的所有者。这种情况下，共享的数据必须活得足够长——至少比所有线程中存活时间最长的那个线程还要久。

------

### 静态变量（Statics）

创建不属于单一线程的最简单方法，是使用 **静态值**（`static`）。静态值属于整个程序，而不是某个线程。
例如：

```rust
static X: [i32; 3] = [1, 2, 3];
thread::spawn(|| dbg!(&X));
thread::spawn(|| dbg!(&X));
```

静态变量有一个常量初始化器，永远不会被丢弃，并且在程序 `main` 函数执行之前就已经存在。每个线程都可以借用它，因为它**保证总是存在**。

------

### 内存泄漏（Leaking）

另一种共享所有权的方式是通过“泄漏”一个分配。使用 `Box::leak`，我们可以释放一个 `Box` 的所有权，并承诺永远不去 `drop` 它。从那一刻起，这个 `Box` 会永远存在，没有所有者，允许任何线程在程序运行期间随意借用它：

```rust
let x: &'static [i32; 3] = Box::leak(Box::new([1, 2, 3]));
thread::spawn(move || dbg!(x));
thread::spawn(move || dbg!(x));
```

虽然闭包使用了 `move`，看起来像是把所有权移动到了线程中，但仔细看 `x` 的类型，会发现我们只是给线程提供了对数据的引用。

> 引用类型是 `Copy` 的，也就是说即使“移动”它们，原始引用依然存在，就像整数或布尔值一样。

注意 `'static` 生命周期并不意味着这个值从程序开始就存在，而只是意味着它会一直活到程序结束。过去的存在与否并不重要。

**缺点**：泄漏 `Box` 会造成内存泄漏。我们分配了内存，但永远不释放它。如果这种情况发生次数有限，还可以接受；但如果持续这样做，程序会慢慢耗尽内存。

------

### 引用计数（Reference Counting）

为了确保共享的数据能在不再使用时被正确释放，我们不能完全放弃它的所有权，而是可以**共享所有权**。通过记录有多少个所有者，可以保证只有在所有者数量为零时才释放值。

Rust 标准库通过 `std::rc::Rc`（Reference Counted）提供了这种功能。它和 `Box` 很相似，但克隆它不会创建新的分配，而是增加存储在值旁边的计数器。原始的 `Rc` 与克隆的 `Rc` 都指向同一块内存，共享所有权：

```rust
use std::rc::Rc;

let a = Rc::new([1, 2, 3]);
let b = a.clone();
assert_eq!(a.as_ptr(), b.as_ptr()); // 指向同一块内存！
```

当一个 `Rc` 被丢弃时，计数器会减少。只有最后一个 `Rc`（计数器变为零时）会释放并回收内存。

**线程安全问题**：如果尝试把 `Rc` 发送到另一个线程，会报错：

```
error[E0277]: `Rc` cannot be sent between threads safely
8 | thread::spawn(move || dbg!(b));
```

`Rc` 并非线程安全。如果多个线程同时持有同一块 `Rc`，它们可能同时修改引用计数器，导致不可预测的结果。


### 原子引用计数（Arc）

为了在线程间安全共享引用计数，需要使用 `std::sync::Arc`（Atomically Reference Counted）。它与 `Rc` 完全相同，但保证对计数器的修改是原子操作，从而线程安全：

```rust
use std::sync::Arc;

let a = Arc::new([1, 2, 3]);
let b = a.clone();

thread::spawn(move || dbg!(a));
thread::spawn(move || dbg!(b));
```

- 我们把数组和计数器放在一起，初始计数为 1。
- 克隆 `Arc` 会把计数器增加到 2，并得到指向同一内存的第二个 `Arc`。
- 每个线程都得到自己的 `Arc`，在丢弃时会递减计数器。
- 最后一个丢弃的线程会把计数器减到 0，并释放数组。

>**克隆命名（Naming Clones）**
>
>如果必须为每个 `Arc` 的克隆赋予不同的名字，代码很快就会变得杂乱且难以阅读。虽然每个克隆都是独立的对象，但它们代表的是同一个共享值，用不同名字并不能很好地反映这一点。
>Rust 允许（并鼓励）通过**变量遮蔽（shadowing）**来复用同一个名字：可以在相同作用域内>定义一个同名的新变量，此时原来的变量就不能再被使用。如果在新的作用域内执行类似 `let a = a.clone();` 的语句，就可以在该作用域中重复使用同一个名字，同时保持外部原始变量仍可用。
>通过在闭包外包裹一个新的作用域（用 `{}`），我们可以在将变量移动到闭包之前克隆它，而无需重新命名：
>
>```rust
>let a = Arc::new([1, 2, 3]);
>let b = a.clone();
>
>thread::spawn(move || {
>dbg!(b);
>});
>dbg!(a);
>```
>在这个例子中，`Arc` 的克隆仍然在相同作用域中存在，每个线程都有自己单独的克隆，并且使用>不同名字。
>另一种方式是在不同作用域中克隆：
>
>```rust
>let a = Arc::new([1, 2, 3]);
>
>thread::spawn({
>let a = a.clone(); // 新作用域中的克隆，遮蔽原变量
>move || { dbg!(a); }
>});
>
>dbg!(a); // 外部的原始变量仍然可用
>```
>
>此时，克隆的 `Arc` 存活在不同作用域中，我们可以在每个线程中使用同样的名字

由于所有权是共享的，引用计数指针（`Rc<T>` 和 `Arc<T>`）与共享引用（`&T`）有相同的限制：**它们不允许修改所包含的值**，因为该值可能正被其他代码借用。

例如，尝试对 `Arc<[i32]>` 内的切片进行排序时，编译器会阻止：

```
error[E0596]: cannot borrow data in an `Arc` as mutable
6 | a.sort();
  | ^^^^^^^^
```

这保证了共享数据在多线程或多处借用场景下的安全性。

## **借用与数据竞争（Borrowing and Data Races）**

在 Rust 中，值可以通过两种方式被借用：

**不可变借用**(Immutable borrowing)
使用 `&` 对某个值进行借用会得到一个不可变引用。这种引用可以被复制。所有这些引用的副本共享对数据的访问。正如名字所示，编译器通常不允许通过不可变引用去修改数据，因为这可能会影响正在同时借用同一数据的其他代码。

**可变借用**(Mutable borrowing)
使用 `&mut` 对某个值进行借用会得到一个可变引用。可变借用保证它是该数据当前唯一的活动借用。这确保了对数据的修改不会影响其他正在访问该数据的代码。

这两种机制共同完全防止了**数据竞争**：即一个线程在修改数据时，另一个线程同时访问它的情况。数据竞争通常会导致未定义行为（undefined behavior），意味着编译器不需要考虑这些情况，它会假设这种情况永远不会发生。

举个例子，来说明编译器如何利用借用规则做出合理假设：

```rust
fn f(a: &i32, b: &mut i32) {
    let before = *a;
    *b += 1;
    let after = *a;
    if before != after {
        x(); // 永远不会发生
    }
}
```

这里，`a` 是对整数的不可变引用，我们在修改 `b` 所指的整数前后分别读取 `a` 的值。编译器可以合理地假设借用规则和数据竞争规则得到了遵守，这意味着 `b` 不可能指向与 `a` 相同的整数。实际上，在 `a` 借用期间，程序中没有任何代码可以可变借用 `a` 指向的整数。因此，编译器可以得出结论：`*a` 不会改变，`if` 条件永远为假，从而可以完全删除对 `x()` 的调用作为优化。

除非使用 `unsafe` 块绕过编译器的安全检查，否则不可能写出违反编译器假设的 Rust 程序。


>**未定义行为（Undefined Behavior）**
>
像 C、C++ 和 Rust 这样的语言都有一套规则，需要遵守，否则会产生所谓的**未定义行为**。例如，Rust 的规则之一是：对任何对象，**最多只能存在一个可变引用**。
>
在 Rust 中，只有使用 `unsafe` 代码时才可能违反这些规则。
“unsafe”并不意味着代码错误或永远不安全，而是编译器不会为你验证代码是否安全。如果代码确实违反了规则，则称为 **不安全（unsound）**。
>
编译器可以假设这些规则永远不会被破坏，而无需检查。如果规则被破坏，就会产生未定义行为，这必须尽力避免。如果允许编译器基于不真实的假设进行优化，很容易导致程序其他部分产生错误结论，从而影响整个程序。
>
举个具体例子，使用切片的 `get_unchecked` 方法：
>
>```rust
>let a = [123, 456, 789];
>let b = unsafe { a.get_unchecked(index) };
>```
>
`get_unchecked` 会返回切片中指定索引的元素，就像 `a[index]` 一样，但它允许编译器假设索引始终在有效范围内，不进行任何检查。
>
这意味着，在此代码中，因为 `a` 的长度是 3，编译器可能假设 `index < 3`。确保这个假设成立是我们的责任。
如果我们破坏了这个假设，例如使用 `index = 3`，可能发生的情况包括：
>
>- 读取内存中 `a` 后面的任意数据；
>- 程序崩溃；
>- 执行程序中完全无关的代码；
>- 产生各种不可预期的后果。
>
>令人惊讶的是，未定义行为甚至可能“逆向传播”，影响先前的代码。例如，假设在前面有一个 >`match` 语句：
>
>```rust
> match index {
>    0 => x(),
>    1 => y(),
>    _ => z(index),
>}
>
>let a = [123, 456, 789];
>let b = unsafe { a.get_unchecked(index) };
>```
>
>由于 `unsafe`，编译器可以假设 `index` 只可能是 0、1 或 2，它可能推断 `match` 的最后一>个分支 `_` 只会匹配 2，从而假设 `z` 只会被调用为 `z(2)`。这一结论不仅可以优化 >`match`，也可能优化 `z` 本身，包括丢弃未使用的代码。
>
>如果实际运行时 `index = 3`，程序可能会尝试执行被优化掉的部分，从而导致完全不可预测的>行为，远在我们到达 `unsafe` 块之前就可能出错。这就是未定义行为可能在程序中**前后传播>**的原因，通常非常难以预料。
>
>**使用 unsafe 函数时，一定要仔细阅读文档**，确保完全理解其安全要求：即作为调用者，需要>遵守哪些假设才能避免未定义行为。
