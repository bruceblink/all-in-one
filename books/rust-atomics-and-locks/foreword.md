---
sidebar_position: 2
typora-root-url: ./..\..\static
---

# 序 Forward


本书对 Rust 语言中的底层并发机制进行了极为出色的概览，涵盖了线程、锁、引用计数、原子操作、邮箱/通道（mailboxes/channels）以及诸多其他内容。书中深入探讨了 CPU 与操作系统层面的相关问题，并对在 Linux、macOS 和 Windows 上正确实现并发代码所固有的挑战进行了总结。我尤其高兴看到，Mara 使用**可实际运行的 Rust 代码**来讲解这些主题。全书最后还讨论了信号量、无锁链表、队列锁（queued locks）、序列锁（sequence locks），甚至还包括 RCU。

那么，这本书究竟能为像我这样的人提供什么价值呢？我已经写了将近 40 年的 C 代码，最近更是长期在 Linux 内核的深层领域中工作。

我最初是从许多热情的 Rust 爱好者以及各种 Linux 相关会议上了解到 Rust 的。尽管如此，在我被一篇 Rust 相关的 LWN 文章["Using Rust for Kernel Development（在内核开发中使用 Rust）"](https://lwn.net/Articles/870555/)点名之前，我一直乐得“各忙各的”。受到这篇文章的触动，我随后写了一系列博客，题为["So You Want to Rust the Linux Kernel?（所以你想用 Rust 重写 Linux 内核？）"](https://paulmck.livejournal.com/62436.html)。这组博客引发了不少热烈的讨论，其中一部分至今仍可以在评论区中看到。

在其中一次讨论中，一位既是资深 Linux 内核开发者、又写过大量 Rust 代码的人告诉我：在 Rust 中编写并发代码时，你应该**按照 Rust 希望的方式来写**。后来我逐渐意识到，这虽然是一个极好的建议，但它也留下了一个关键问题——**Rust 到底“希望”你怎么写？**
本书对这个问题给出了极为出色的回答，因此它不仅对希望学习并发的 Rust 开发者极具价值，也同样适合那些使用其他语言、但想了解如何在 Rust 中正确编写并发代码的并发程序开发者。

当然，我本人正属于后者。不过我必须坦言，围绕 Rust 并发的许多激烈讨论，总让我想起父母和祖父母当年对电锯、电钻等电动工具上新增的各种“碍事”的安全装置的抱怨。如今，其中一些安全特性已经无处不在；但锤子、凿子和链锯却并没有发生太大的变化。当年要判断哪些机械安全特性能经受住时间的考验，并非易事。因此，我建议我们在看待软件安全特性时，应当抱持一种**深刻的谦逊态度**。请理解，我这番话既是对这些特性的支持者说的，也是对它们的反对者说的。

这也引出了另一类潜在读者——**Rust 怀疑论者**。虽然我确实认为，大多数 Rust 怀疑论者通过指出改进空间，为社区做出了有价值的贡献，但除非是对 Rust 非常精通的怀疑者，否则阅读本书都会大有裨益。至少，这能帮助他们提出更犀利、也更有针对性的批评。

还有一些根深蒂固的非 Rust 开发者，他们更倾向于在自己钟爱的语言中实现 Rust 的并发安全机制。本书将帮助他们更深入地理解这些 Rust 机制——无论是为了复刻，还是（更好地）加以改进。

最后，还有相当一部分 Linux 内核开发者正在关注 Rust 朝着被纳入 Linux 内核所取得的进展；例如 Jonathan Corbet 的文章["Next Steps for Rust in the Kernel（Rust 进入内核的下一步）"](https://lwn.net/Articles/908347/)。截至 2022 年 10 月，这仍然是一项实验，但它正被越来越严肃地对待。事实上，严肃到 Linus Torvalds 已经在 Linux 内核 6.1 版本中接受了第一批 Rust 语言支持代码。

无论你阅读本书，是为了将并发纳入你的 Rust 技能版图，还是为了将 Rust 纳入你的并发技能版图，抑或是为了改进现有的非 Rust 环境，或者只是想从一个不同的视角审视并发问题，我都衷心祝愿你在这段旅程中一切顺利！

—— Paul E. McKenney

Meta Platforms Kernel Team

Meta

October 2022