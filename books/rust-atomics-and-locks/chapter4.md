---
sidebar_position: 7
typora-root-url: ./..\..\static
---

# 第 4 章 构建我们自己的自旋锁（Building Our Own Spin Lock）

锁住一个常规的互斥锁（参见[“加锁：互斥锁和读写锁”](chapter1#加锁mutex-与-rwlocklocking-mutexes-and-rwlocks)）在互斥锁已被锁定时会导致你的线程进入睡眠状态。这避免了在等待锁释放时浪费资源。但是，如果一个锁只会被持有非常短暂的时间，并且锁定它的线程可以在不同的处理器核心上并行运行，那么让线程反复尝试去锁定它而不真正进入睡眠状态可能更好。

**自旋锁**正是这样的一种互斥锁。尝试锁定一个已经锁定的互斥锁将导致忙循环或自旋：反复尝试直到最终成功。这可能会浪费处理器周期，但在锁定时有时能带来更低的延迟。

> 许多现实世界中的互斥锁实现，包括某些平台上的 `std::sync::Mutex`，在请求操作系统让线程睡眠之前，会短暂地表现得像一个自旋锁。这是尝试结合两者的优点，尽管这种行为是否有益完全取决于具体的使用场景。

在本章中，我们将构建自己的 `SpinLock` 类型，应用我们在第2章和第3章中学到的知识，并看看如何利用 Rust 的类型系统为我们的 `SpinLock` 用户提供一个安全且有用的接口。

## **一个最小的实现**（A Minimal Implementation）

让我们从头开始实现这样一个自旋锁。

最精简的版本非常简单，如下所示：
```rust
pub struct SpinLock {
    locked: AtomicBool,
}
```
我们只需要一个布尔值来指示它是否被锁定。我们使用原子布尔值，因为我们希望多个线程能够同时与其交互。

然后我们只需要一个构造函数，以及 `lock` 和 `unlock` 方法：
```rust
impl SpinLock {
    pub const fn new() -> Self {
        Self { locked: AtomicBool::new(false) }
    }

    pub fn lock(&self) {
        while self.locked.swap(true, Acquire) {
            std::hint::spin_loop();
        }
    }

    pub fn unlock(&self) {
        self.locked.store(false, Release);
    }
}
```
锁定的布尔值初始为 `false`，`lock` 方法将其交换为 `true` 并在它已经是 `true` 时持续尝试，而 `unlock` 方法只是将其设回 `false`。

> 我们也可以使用比较并交换操作来原子性地检查布尔值是否为 `false` 并在是的情况下将其设为 `true`，而不是使用交换操作：
>
> ​    `self.locked.compare_exchange_weak(false, true, Acquire, Relaxed).is_ok()`
>
> 虽然更冗长一些，但根据你的偏好，这可能更容易理解，因为它更清晰地捕捉了操作可能失败或成功这一概念。然而，这也可能导致略有不同的指令，我们将在第7章看到。

在 `while` 循环中，我们使用了自旋循环提示，它告诉处理器我们正在自旋等待某些变化。在大多数主要平台上，此提示会导致一条特殊指令，使处理器核心为此类情况优化其行为。例如，它可能会暂时减慢速度或优先处理其他有用的事情。然而，与 `thread::sleep` 或 `thread::park` 等阻塞操作不同，自旋循环提示并不会导致操作系统被调用来让你的线程进入睡眠以让位给另一个线程。

> 通常，在自旋循环中包含这样的提示是个好主意。根据具体情况，甚至在再次尝试访问原子变量之前多次执行此提示可能也是有益的。如果你关心最后几纳秒的性能并想找到最优策略，你必须对你特定的使用场景进行基准测试。不幸的是，正如我们将在第7章看到的那样，此类基准测试的结论可能高度依赖于硬件。

我们使用获取和释放内存排序来确保每次 `unlock()` 调用与后续的 `lock()` 调用之间建立起一个“发生在之前”关系。换句话说，确保在锁定之后，我们可以安全地假设在上次被锁定期间发生的任何事情都已经发生了。这是获取和释放排序最经典的用例：获取和释放一个锁。

图4-1 展示了我们的 `SpinLock` 被用来保护对某些共享数据的访问，且有两个线程并发尝试获取锁的情况。请注意第一个线程上的 `unlock` 操作如何与第二个线程上的 `lock` 操作形成“发生在之前”关系，这确保了线程无法并发访问数据。

![figure-4-1](/img/rust-atomics-and-locks/chapter4/figure-4-1.png)

**图4-1. 两个线程使用我们的 `SpinLock` 保护对某些共享数据的访问时，它们之间的“发生在之前”关系**

